/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/core-util-is/lib/util.js?");

/***/ }),

/***/ "./node_modules/cssauron-glsl/index.js":
/*!*********************************************!*\
  !*** ./node_modules/cssauron-glsl/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! cssauron */ \"./node_modules/cssauron/index.js\")({\n  tag: 'type'\n, parent: 'parent'\n, children: 'children'\n, contents: 'data'\n, attr: function(node, attr) { return node[attr] }\n})\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/cssauron-glsl/index.js?");

/***/ }),

/***/ "./node_modules/cssauron/index.js":
/*!****************************************!*\
  !*** ./node_modules/cssauron/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = language\n\nvar tokenizer = __webpack_require__(/*! ./tokenizer */ \"./node_modules/cssauron/tokenizer.js\")\n\nfunction language(lookups, matchComparison) {\n  return function(selector) {\n    return parse(selector, remap(lookups),\n                 matchComparison || caseSensitiveComparison)\n  }\n}\n\nfunction remap(opts) {\n  for(var key in opts) if(opt_okay(opts, key)) {\n    opts[key] = Function(\n        'return function(node, attr) { return node.' + opts[key] + ' }'\n    )\n    opts[key] = opts[key]()\n  }\n\n  return opts\n}\n\nfunction opt_okay(opts, key) {\n  return opts.hasOwnProperty(key) && typeof opts[key] === 'string'\n}\n\nfunction parse(selector, options, matchComparison) {\n  var stream = tokenizer()\n    , default_subj = true\n    , selectors = [[]]\n    , traversal\n    , bits\n\n  bits = selectors[0]\n\n  traversal = {\n      '': any_parents\n    , '>': direct_parent\n    , '+': direct_sibling\n    , '~': any_sibling\n  }\n\n  stream\n    .on('data', group)\n    .end(selector)\n\n  function group(token) {\n    var crnt\n\n    if(token.type === 'comma') {\n      selectors.unshift(bits = [])\n\n      return\n    }\n\n    if(token.type === 'op' || token.type === 'any-child') {\n      bits.unshift(traversal[token.data])\n      bits.unshift(check())\n\n      return\n    }\n\n    bits[0] = bits[0] || check()\n    crnt = bits[0]\n\n    if(token.type === '!') {\n      crnt.subject =\n      selectors[0].subject = true\n\n      return\n    }\n\n    crnt.push(\n        token.type === 'class' ? listContains(token.type, token.data) :\n        token.type === 'attr' ? attr(token) :\n        token.type === ':' || token.type === '::' ? pseudo(token) :\n        token.type === '*' ? Boolean :\n        matches(token.type, token.data, matchComparison)\n    )\n  }\n\n  return selector_fn\n\n  function selector_fn(node, as_boolean) {\n    var current\n      , length\n      , orig\n      , subj\n      , set\n\n    orig = node\n    set = []\n\n    for(var i = 0, len = selectors.length; i < len; ++i) {\n      bits = selectors[i]\n      current = entry\n      length = bits.length\n      node = orig\n      subj = []\n\n      for(var j = 0; j < length; j += 2) {\n        node = current(node, bits[j], subj)\n\n        if(!node) {\n          break\n        }\n\n        current = bits[j + 1]\n      }\n\n      if(j >= length) {\n        if(as_boolean) {\n          return true\n        }\n\n        add(!bits.subject ? [orig] : subj)\n      }\n    }\n\n    if(as_boolean) {\n      return false\n    }\n\n    return !set.length ? false :\n            set.length === 1 ? set[0] :\n            set\n\n    function add(items) {\n      var next\n\n      while(items.length) {\n        next = items.shift()\n\n        if(set.indexOf(next) === -1) {\n          set.push(next)\n        }\n      }\n    }\n  }\n\n  function check() {\n    _check.bits = []\n    _check.subject = false\n    _check.push = function(token) {\n      _check.bits.push(token)\n    }\n\n    return _check\n\n    function _check(node, subj) {\n      for(var i = 0, len = _check.bits.length; i < len; ++i) {\n        if(!_check.bits[i](node)) {\n          return false\n        }\n      }\n\n      if(_check.subject) {\n        subj.push(node)\n      }\n\n      return true\n    }\n  }\n\n  function listContains(type, data) {\n    return function(node) {\n      var val = options[type](node)\n      val =\n        Array.isArray(val) ? val :\n        val ? val.toString().split(/\\s+/) :\n        []\n      return val.indexOf(data) >= 0\n    }\n  }\n\n  function attr(token) {\n    return token.data.lhs ?\n      valid_attr(\n          options.attr\n        , token.data.lhs\n        , token.data.cmp\n        , token.data.rhs\n      ) :\n      valid_attr(options.attr, token.data)\n  }\n\n  function matches(type, data, matchComparison) {\n    return function(node) {\n      return matchComparison(type, options[type](node), data);\n    }\n  }\n\n  function any_parents(node, next, subj) {\n    do {\n      node = options.parent(node)\n    } while(node && !next(node, subj))\n\n    return node\n  }\n\n  function direct_parent(node, next, subj) {\n    node = options.parent(node)\n\n    return node && next(node, subj) ? node : null\n  }\n\n  function direct_sibling(node, next, subj) {\n    var parent = options.parent(node)\n      , idx = 0\n      , children\n\n    children = options.children(parent)\n\n    for(var i = 0, len = children.length; i < len; ++i) {\n      if(children[i] === node) {\n        idx = i\n\n        break\n      }\n    }\n\n    return children[idx - 1] && next(children[idx - 1], subj) ?\n      children[idx - 1] :\n      null\n  }\n\n  function any_sibling(node, next, subj) {\n    var parent = options.parent(node)\n      , children\n\n    children = options.children(parent)\n\n    for(var i = 0, len = children.length; i < len; ++i) {\n      if(children[i] === node) {\n        return null\n      }\n\n      if(next(children[i], subj)) {\n        return children[i]\n      }\n    }\n\n    return null\n  }\n\n  function pseudo(token) {\n    return valid_pseudo(options, token.data, matchComparison)\n  }\n\n}\n\nfunction entry(node, next, subj) {\n  return next(node, subj) ? node : null\n}\n\nfunction valid_pseudo(options, match, matchComparison) {\n  switch(match) {\n    case 'empty': return valid_empty(options)\n    case 'first-child': return valid_first_child(options)\n    case 'last-child': return valid_last_child(options)\n    case 'root': return valid_root(options)\n  }\n\n  if(match.indexOf('contains') === 0) {\n    return valid_contains(options, match.slice(9, -1))\n  }\n\n  if(match.indexOf('any') === 0) {\n    return valid_any_match(options, match.slice(4, -1), matchComparison)\n  }\n\n  if(match.indexOf('not') === 0) {\n    return valid_not_match(options, match.slice(4, -1), matchComparison)\n  }\n\n  if(match.indexOf('nth-child') === 0) {\n    return valid_nth_child(options, match.slice(10, -1))\n  }\n\n  return function() {\n    return false\n  }\n}\n\nfunction valid_not_match(options, selector, matchComparison) {\n  var fn = parse(selector, options, matchComparison)\n\n  return not_function\n\n  function not_function(node) {\n    return !fn(node, true)\n  }\n}\n\nfunction valid_any_match(options, selector, matchComparison) {\n  var fn = parse(selector, options, matchComparison)\n\n  return fn\n}\n\nfunction valid_attr(fn, lhs, cmp, rhs) {\n  return function(node) {\n    var attr = fn(node, lhs)\n\n    if(!cmp) {\n      return !!attr\n    }\n\n    if(cmp.length === 1) {\n      return attr == rhs\n    }\n\n    if(attr === void 0 || attr === null) {\n      return false\n    }\n\n    return checkattr[cmp.charAt(0)](attr, rhs)\n  }\n}\n\nfunction valid_first_child(options) {\n  return function(node) {\n    return options.children(options.parent(node))[0] === node\n  }\n}\n\nfunction valid_last_child(options) {\n  return function(node) {\n    var children = options.children(options.parent(node))\n\n    return children[children.length - 1] === node\n  }\n}\n\nfunction valid_empty(options) {\n  return function(node) {\n    return options.children(node).length === 0\n  }\n}\n\nfunction valid_root(options) {\n  return function(node) {\n    return !options.parent(node)\n  }\n}\n\nfunction valid_contains(options, contents) {\n  return function(node) {\n    return options.contents(node).indexOf(contents) !== -1\n  }\n}\n\nfunction valid_nth_child(options, nth) {\n  var test = function(){ return false }\n  if (nth == 'odd') {\n    nth = '2n+1'\n  } else if (nth == 'even') {\n    nth = '2n'\n  }\n  var regexp = /( ?([-|\\+])?(\\d*)n)? ?((\\+|-)? ?(\\d+))? ?/\n  var matches = nth.match(regexp)\n  if (matches) {\n    var growth = 0;\n    if (matches[1]) {\n      var positiveGrowth = (matches[2] != '-')\n      growth = parseInt(matches[3] == '' ? 1 : matches[3])\n      growth = growth * (positiveGrowth ? 1 : -1)\n    }\n    var offset = 0\n    if (matches[4]) {\n      offset = parseInt(matches[6])\n      var positiveOffset = (matches[5] != '-')\n      offset = offset * (positiveOffset ? 1 : -1)\n    }\n    if (growth == 0) {\n      if (offset != 0) {\n        test = function(children, node) {\n          return children[offset - 1] === node\n        }\n      }\n    } else {\n      test = function(children, node) {\n        var validPositions = []\n        var len = children.length\n        for (var position=1; position <= len; position++) {\n          var divisible = ((position - offset) % growth) == 0;\n          if (divisible) {\n            if (growth > 0) {\n              validPositions.push(position);\n            } else {\n              if ((position - offset) / growth >= 0) {\n                validPositions.push(position);\n              }\n            }\n          }\n        }\n        for(var i=0; i < validPositions.length; i++) {\n          if (children[validPositions[i] - 1] === node) {\n            return true\n          }\n        }\n        return false\n      }\n    }\n  }\n  return function(node) {\n    var children = options.children(options.parent(node))\n\n    return test(children, node)\n  }\n}\n\nvar checkattr = {\n    '$': check_end\n  , '^': check_beg\n  , '*': check_any\n  , '~': check_spc\n  , '|': check_dsh\n}\n\nfunction check_end(l, r) {\n  return l.slice(l.length - r.length) === r\n}\n\nfunction check_beg(l, r) {\n  return l.slice(0, r.length) === r\n}\n\nfunction check_any(l, r) {\n  return l.indexOf(r) > -1\n}\n\nfunction check_spc(l, r) {\n  return l.split(/\\s+/).indexOf(r) > -1\n}\n\nfunction check_dsh(l, r) {\n  return l.split('-').indexOf(r) > -1\n}\n\nfunction caseSensitiveComparison(type, pattern, data) {\n  return pattern === data;\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/cssauron/index.js?");

/***/ }),

/***/ "./node_modules/cssauron/tokenizer.js":
/*!********************************************!*\
  !*** ./node_modules/cssauron/tokenizer.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = tokenize\n\nvar through = __webpack_require__(/*! through */ \"./node_modules/through/index.js\")\n\nvar PSEUDOSTART = 'pseudo-start'\n  , ATTR_START = 'attr-start'\n  , ANY_CHILD = 'any-child'\n  , ATTR_COMP = 'attr-comp'\n  , ATTR_END = 'attr-end'\n  , PSEUDOPSEUDO = '::'\n  , PSEUDOCLASS = ':'\n  , READY = '(ready)'\n  , OPERATION = 'op'\n  , CLASS = 'class'\n  , COMMA = 'comma'\n  , ATTR = 'attr'\n  , SUBJECT = '!'\n  , TAG = 'tag'\n  , STAR = '*'\n  , ID = 'id'\n\nfunction tokenize() {\n  var escaped = false\n    , gathered = []\n    , state = READY \n    , data = []\n    , idx = 0\n    , stream\n    , length\n    , quote\n    , depth\n    , lhs\n    , rhs\n    , cmp\n    , c\n\n  return stream = through(ondata, onend)\n\n  function ondata(chunk) {\n    data = data.concat(chunk.split(''))\n    length = data.length\n\n    while(idx < length && (c = data[idx++])) {\n      switch(state) {\n        case READY: state_ready(); break\n        case ANY_CHILD: state_any_child(); break\n        case OPERATION: state_op(); break\n        case ATTR_START: state_attr_start(); break\n        case ATTR_COMP: state_attr_compare(); break\n        case ATTR_END: state_attr_end(); break\n        case PSEUDOCLASS:\n        case PSEUDOPSEUDO: state_pseudo(); break\n        case PSEUDOSTART: state_pseudostart(); break\n        case ID:\n        case TAG:\n        case CLASS: state_gather(); break\n      }\n    }\n\n    data = data.slice(idx)\n  }\n\n  function onend(chunk) {\n    if(arguments.length) {\n      ondata(chunk)\n    }\n\n    if(gathered.length) {\n      stream.queue(token())\n    }\n  }\n\n  function state_ready() {\n    switch(true) {\n      case '#' === c: state = ID; break\n      case '.' === c: state = CLASS; break\n      case ':' === c: state = PSEUDOCLASS; break\n      case '[' === c: state = ATTR_START; break\n      case '!' === c: subject(); break\n      case '*' === c: star(); break\n      case ',' === c: comma(); break\n      case /[>\\+~]/.test(c): state = OPERATION; break\n      case /\\s/.test(c): state = ANY_CHILD; break\n      case /[\\w\\d\\-_]/.test(c): state = TAG; --idx; break\n    }\n  }\n\n  function subject() {\n    state = SUBJECT\n    gathered = ['!']\n    stream.queue(token())\n    state = READY\n  }\n\n  function star() {\n    state = STAR\n    gathered = ['*']\n    stream.queue(token())\n    state = READY\n  }\n\n  function comma() {\n    state = COMMA\n    gathered = [',']\n    stream.queue(token())\n    state = READY\n  }\n\n  function state_op() {\n    if(/[>\\+~]/.test(c)) {\n      return gathered.push(c)\n    }\n\n    // chomp down the following whitespace.\n    if(/\\s/.test(c)) {\n      return\n    }\n\n    stream.queue(token())\n    state = READY\n    --idx\n  }\n\n  function state_any_child() {\n    if(/\\s/.test(c)) {\n      return\n    }\n\n    if(/[>\\+~]/.test(c)) {\n      return --idx, state = OPERATION\n    }\n\n    stream.queue(token())\n    state = READY\n    --idx\n  }\n\n  function state_pseudo() {\n    rhs = state\n    state_gather(true)\n\n    if(state !== READY) {\n      return\n    }\n\n    if(c === '(') {\n      lhs = gathered.join('')\n      state = PSEUDOSTART\n      gathered.length = 0\n      depth = 1\n      ++idx\n\n      return\n    }\n\n    state = PSEUDOCLASS\n    stream.queue(token())\n    state = READY\n  }\n\n  function state_pseudostart() {\n    if(gathered.length === 0 && !quote) {\n      quote = /['\"]/.test(c) ? c : null\n\n      if(quote) {\n        return\n      }\n    }\n\n    if(quote) {\n      if(!escaped && c === quote) {\n        quote = null\n\n        return\n      }\n\n      if(c === '\\\\') {\n        escaped ? gathered.push(c) : (escaped = true)\n\n        return\n      }\n\n      escaped = false\n      gathered.push(c)\n\n      return\n    }\n\n    gathered.push(c)\n\n    if(c === '(') {\n      ++depth\n    } else if(c === ')') {\n      --depth\n    }\n    \n    if(!depth) {\n      gathered.pop()\n      stream.queue({\n          type: rhs \n        , data: lhs + '(' + gathered.join('') + ')'\n      })\n\n      state = READY\n      lhs = rhs = cmp = null\n      gathered.length = 0\n    }\n\n    return \n  }\n\n  function state_attr_start() {\n    state_gather(true)\n\n    if(state !== READY) {\n      return\n    }\n\n    if(c === ']') {\n      state = ATTR\n      stream.queue(token())\n      state = READY\n\n      return\n    }\n\n    lhs = gathered.join('')\n    gathered.length = 0\n    state = ATTR_COMP\n  }\n\n  function state_attr_compare() {\n    if(/[=~|$^*]/.test(c)) {\n      gathered.push(c)\n    }\n\n    if(gathered.length === 2 || c === '=') {\n      cmp = gathered.join('')\n      gathered.length = 0\n      state = ATTR_END\n      quote = null\n\n      return\n    }\n  }\n\n  function state_attr_end() {\n    if(!gathered.length && !quote) {\n      quote = /['\"]/.test(c) ? c : null\n\n      if(quote) {\n        return\n      }\n    }\n\n    if(quote) {\n      if(!escaped && c === quote) {\n        quote = null\n\n        return\n      }\n\n      if(c === '\\\\') {\n        if(escaped) {\n          gathered.push(c)\n        }\n\n        escaped = !escaped\n\n        return\n      }\n\n      escaped = false\n      gathered.push(c)\n\n      return\n    }\n\n    state_gather(true)\n\n    if(state !== READY) {\n      return\n    }\n\n    stream.queue({\n        type: ATTR\n      , data: {\n            lhs: lhs\n          , rhs: gathered.join('')\n          , cmp: cmp\n        }\n    })\n\n    state = READY\n    lhs = rhs = cmp = null\n    gathered.length = 0\n\n    return \n  }\n\n  function state_gather(quietly) {\n    if(/[^\\d\\w\\-_]/.test(c) && !escaped) {\n      if(c === '\\\\') {\n        escaped = true\n      } else {\n        !quietly && stream.queue(token())\n        state = READY\n        --idx\n      }\n\n      return\n    }\n\n    escaped = false\n    gathered.push(c)\n  }\n\n  function token() {\n    var data = gathered.join('')\n\n    gathered.length = 0\n\n    return {\n        type: state\n      , data: data\n    }\n  }\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/cssauron/tokenizer.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EPSILON\": () => (/* binding */ EPSILON),\n/* harmony export */   \"ARRAY_TYPE\": () => (/* binding */ ARRAY_TYPE),\n/* harmony export */   \"RANDOM\": () => (/* binding */ RANDOM),\n/* harmony export */   \"setMatrixArrayType\": () => (/* binding */ setMatrixArrayType),\n/* harmony export */   \"toRadian\": () => (/* binding */ toRadian),\n/* harmony export */   \"equals\": () => (/* binding */ equals)\n/* harmony export */ });\n/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nvar EPSILON = 0.000001;\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nvar RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nfunction setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nfunction toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};\n\n//# sourceURL=webpack://webgl-month/./node_modules/gl-matrix/esm/common.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"identity\": () => (/* binding */ identity),\n/* harmony export */   \"transpose\": () => (/* binding */ transpose),\n/* harmony export */   \"invert\": () => (/* binding */ invert),\n/* harmony export */   \"adjoint\": () => (/* binding */ adjoint),\n/* harmony export */   \"determinant\": () => (/* binding */ determinant),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"translate\": () => (/* binding */ translate),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"rotate\": () => (/* binding */ rotate),\n/* harmony export */   \"rotateX\": () => (/* binding */ rotateX),\n/* harmony export */   \"rotateY\": () => (/* binding */ rotateY),\n/* harmony export */   \"rotateZ\": () => (/* binding */ rotateZ),\n/* harmony export */   \"fromTranslation\": () => (/* binding */ fromTranslation),\n/* harmony export */   \"fromScaling\": () => (/* binding */ fromScaling),\n/* harmony export */   \"fromRotation\": () => (/* binding */ fromRotation),\n/* harmony export */   \"fromXRotation\": () => (/* binding */ fromXRotation),\n/* harmony export */   \"fromYRotation\": () => (/* binding */ fromYRotation),\n/* harmony export */   \"fromZRotation\": () => (/* binding */ fromZRotation),\n/* harmony export */   \"fromRotationTranslation\": () => (/* binding */ fromRotationTranslation),\n/* harmony export */   \"fromQuat2\": () => (/* binding */ fromQuat2),\n/* harmony export */   \"getTranslation\": () => (/* binding */ getTranslation),\n/* harmony export */   \"getScaling\": () => (/* binding */ getScaling),\n/* harmony export */   \"getRotation\": () => (/* binding */ getRotation),\n/* harmony export */   \"fromRotationTranslationScale\": () => (/* binding */ fromRotationTranslationScale),\n/* harmony export */   \"fromRotationTranslationScaleOrigin\": () => (/* binding */ fromRotationTranslationScaleOrigin),\n/* harmony export */   \"fromQuat\": () => (/* binding */ fromQuat),\n/* harmony export */   \"frustum\": () => (/* binding */ frustum),\n/* harmony export */   \"perspectiveNO\": () => (/* binding */ perspectiveNO),\n/* harmony export */   \"perspective\": () => (/* binding */ perspective),\n/* harmony export */   \"perspectiveZO\": () => (/* binding */ perspectiveZO),\n/* harmony export */   \"perspectiveFromFieldOfView\": () => (/* binding */ perspectiveFromFieldOfView),\n/* harmony export */   \"orthoNO\": () => (/* binding */ orthoNO),\n/* harmony export */   \"ortho\": () => (/* binding */ ortho),\n/* harmony export */   \"orthoZO\": () => (/* binding */ orthoZO),\n/* harmony export */   \"lookAt\": () => (/* binding */ lookAt),\n/* harmony export */   \"targetTo\": () => (/* binding */ targetTo),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"frob\": () => (/* binding */ frob),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"multiplyScalar\": () => (/* binding */ multiplyScalar),\n/* harmony export */   \"multiplyScalarAndAdd\": () => (/* binding */ multiplyScalarAndAdd),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"sub\": () => (/* binding */ sub)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\n * @module mat4\n */\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\n\nfunction fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\n\nfunction set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the source matrix\n * @returns {mat4} out\n */\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\n * Calculates the determinant of a mat4\n *\n * @param {ReadonlyMat4} a the source matrix\n * @returns {Number} determinant of a\n */\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to translate\n * @param {ReadonlyVec3} v vector to translate by\n * @returns {mat4} out\n */\n\nfunction translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\n\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyVec3} v Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {ReadonlyVec3} axis the axis to rotate around\n * @returns {mat4} out\n */\n\nfunction fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n\nfunction fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a new mat4 from a dual quat.\n *\n * @param {mat4} out Matrix\n * @param {ReadonlyQuat2} a Dual Quaternion\n * @returns {mat4} mat4 receiving operation result\n */\n\nfunction fromQuat2(out, a) {\n  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\n\nfunction getRotation(out, mat) {\n  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {ReadonlyVec3} v Translation vector\n * @param {ReadonlyVec3} s Scaling vector\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\n\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nfunction perspectiveNO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\n * Alias for {@link mat4.perspectiveNO}\n * @function\n */\n\nvar perspective = perspectiveNO;\n/**\n * Generates a perspective projection matrix suitable for WebGPU with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n * Passing null/undefined/no value for far will generate infinite projection matrix.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum, can be null or Infinity\n * @returns {mat4} out\n */\n\nfunction perspectiveZO(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n\n  return out;\n}\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],\n * which matches WebGL/OpenGL's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction orthoNO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Alias for {@link mat4.orthoNO}\n * @function\n */\n\nvar ortho = orthoNO;\n/**\n * Generates a orthogonal projection matrix with the given bounds.\n * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],\n * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\n\nfunction orthoZO(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = near * nf;\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {ReadonlyVec3} eye Position of the viewer\n * @param {ReadonlyVec3} center Point the viewer is looking at\n * @param {ReadonlyVec3} up vec3 pointing up\n * @returns {mat4} out\n */\n\nfunction targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\n * Returns a string representation of a mat4\n *\n * @param {ReadonlyMat4} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\n\nfunction str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @returns {mat4} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {ReadonlyMat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {ReadonlyMat4} a the first operand\n * @param {ReadonlyMat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat4} a The first matrix.\n * @param {ReadonlyMat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\n\nvar sub = subtract;\n\n//# sourceURL=webpack://webgl-month/./node_modules/gl-matrix/esm/mat4.js?");

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"length\": () => (/* binding */ length),\n/* harmony export */   \"fromValues\": () => (/* binding */ fromValues),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"subtract\": () => (/* binding */ subtract),\n/* harmony export */   \"multiply\": () => (/* binding */ multiply),\n/* harmony export */   \"divide\": () => (/* binding */ divide),\n/* harmony export */   \"ceil\": () => (/* binding */ ceil),\n/* harmony export */   \"floor\": () => (/* binding */ floor),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"round\": () => (/* binding */ round),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"scaleAndAdd\": () => (/* binding */ scaleAndAdd),\n/* harmony export */   \"distance\": () => (/* binding */ distance),\n/* harmony export */   \"squaredDistance\": () => (/* binding */ squaredDistance),\n/* harmony export */   \"squaredLength\": () => (/* binding */ squaredLength),\n/* harmony export */   \"negate\": () => (/* binding */ negate),\n/* harmony export */   \"inverse\": () => (/* binding */ inverse),\n/* harmony export */   \"normalize\": () => (/* binding */ normalize),\n/* harmony export */   \"dot\": () => (/* binding */ dot),\n/* harmony export */   \"cross\": () => (/* binding */ cross),\n/* harmony export */   \"lerp\": () => (/* binding */ lerp),\n/* harmony export */   \"hermite\": () => (/* binding */ hermite),\n/* harmony export */   \"bezier\": () => (/* binding */ bezier),\n/* harmony export */   \"random\": () => (/* binding */ random),\n/* harmony export */   \"transformMat4\": () => (/* binding */ transformMat4),\n/* harmony export */   \"transformMat3\": () => (/* binding */ transformMat3),\n/* harmony export */   \"transformQuat\": () => (/* binding */ transformQuat),\n/* harmony export */   \"rotateX\": () => (/* binding */ rotateX),\n/* harmony export */   \"rotateY\": () => (/* binding */ rotateY),\n/* harmony export */   \"rotateZ\": () => (/* binding */ rotateZ),\n/* harmony export */   \"angle\": () => (/* binding */ angle),\n/* harmony export */   \"zero\": () => (/* binding */ zero),\n/* harmony export */   \"str\": () => (/* binding */ str),\n/* harmony export */   \"exactEquals\": () => (/* binding */ exactEquals),\n/* harmony export */   \"equals\": () => (/* binding */ equals),\n/* harmony export */   \"sub\": () => (/* binding */ sub),\n/* harmony export */   \"mul\": () => (/* binding */ mul),\n/* harmony export */   \"div\": () => (/* binding */ div),\n/* harmony export */   \"dist\": () => (/* binding */ dist),\n/* harmony export */   \"sqrDist\": () => (/* binding */ sqrDist),\n/* harmony export */   \"len\": () => (/* binding */ len),\n/* harmony export */   \"sqrLen\": () => (/* binding */ sqrLen),\n/* harmony export */   \"forEach\": () => (/* binding */ forEach)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/esm/common.js\");\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nfunction create() {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nfunction clone(a) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nfunction fromValues(x, y, z) {\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nfunction set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nfunction cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 * Math.PI;\n  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nfunction transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nfunction rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nfunction angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nfunction str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nvar sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nvar mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nvar div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nvar dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nvar sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nvar len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nvar sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();\n\n//# sourceURL=webpack://webgl-month/./node_modules/gl-matrix/esm/vec3.js?");

/***/ }),

/***/ "./node_modules/glsl-deparser/index.js":
/*!*********************************************!*\
  !*** ./node_modules/glsl-deparser/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/index */ \"./node_modules/glsl-deparser/lib/index.js\")\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-deparser/index.js?");

/***/ }),

/***/ "./node_modules/glsl-deparser/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/glsl-deparser/lib/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = deparse_stream\n\nvar through = __webpack_require__(/*! through */ \"./node_modules/glsl-deparser/node_modules/through/index.js\")\n  , language = __webpack_require__(/*! cssauron-glsl */ \"./node_modules/cssauron-glsl/index.js\")\n  , WSManager = __webpack_require__(/*! ./ws */ \"./node_modules/glsl-deparser/lib/ws.js\")\n\nvar types =\n{ 'binary':       deparse_binary\n, 'break':        deparse_break\n, 'builtin':      deparse_builtin\n, 'continue':     deparse_continue\n, 'decl':         deparse_decl\n, 'decllist':     deparse_decllist\n, 'discard':      deparse_discard\n, 'do-while':     deparse_do_while\n, 'expr':         deparse_expr\n, 'forloop':      deparse_forloop\n, 'function':     deparse_function\n, 'functionargs': deparse_functionargs\n, 'ident':        deparse_ident\n, 'if':           deparse_if\n, 'keyword':      deparse_keyword\n, 'literal':      deparse_literal\n, 'precision':    deparse_precision\n, 'preprocessor': deparse_preprocessor\n, 'return':       deparse_return\n, 'stmt':         deparse_stmt\n, 'stmtlist':     deparse_stmtlist\n, 'struct':       deparse_struct\n, 'assign':       deparse_assign\n, 'unary':        deparse_unary\n, 'whileloop':    deparse_whileloop\n, 'operator':     deparse_operator\n, 'group':        deparse_group\n, 'suffix':       deparse_suffix\n, 'call':         deparse_call\n, 'quantifier':   deparse_quantifier\n, 'ternary':      deparse_ternary }\n\nvar needs_semicolon = {\n  'decl': true\n, 'return': true\n, 'break': true\n, 'continue': true\n, 'discard': true\n, 'precision': true\n, 'expr': true\n, 'do-while': true\n, 'struct': true\n}\n\n// semi-globals\nvar output = []\n  , ws\n\nfunction deparse_stream(with_whitespace, indent) {\n  with_whitespace = with_whitespace === undefined ? true : with_whitespace\n\n  var stream = through(recv, end)\n    , whitespace = new WSManager(with_whitespace, indent || '  ')\n\n\n  stream.parseable = language(':root > *') \n  \n  return stream\n\n  function recv(node) {\n    if(!stream.parseable(node)) return\n\n    // reuse the old array.\n    output.length = 0\n    // reassign the semi-global \"ws\"\n    ws = whitespace\n\n    deparse(node)\n\n    stream.queue(output.join(''))\n  }\n\n  function end() {\n    stream.queue(null)\n  }\n}\n\nfunction deparse(n) {\n  return types[n.type](n)\n}\n\nfunction deparse_suffix(node) {\n  deparse(node.children[0])\n  output.push(node.data)\n}\n\nfunction deparse_binary(node) {\n  var is_bracket = node.data === '['\n\n  deparse(node.children[0])\n  !is_bracket && output.push(ws.optional(' '))\n  output.push(node.data)\n  !is_bracket && output.push(ws.optional(' '))\n  deparse(node.children[1])\n\n  if(is_bracket) {\n    output.push(']')\n  }\n}\n\nfunction deparse_break(node) {\n  output.push('break')\n}\n\nfunction deparse_builtin(node) {\n  output.push(node.data)\n}\n\nfunction deparse_continue(node) {\n  output.push('continue')\n}\n\nfunction deparse_decl(node) {\n  // it's five long\n  var len = node.children.length\n    , len_minus_one = len - 1\n\n  for(var i = 0; i < len; ++i) {\n    if(node.children[i].type !== 'placeholder') {\n      deparse(node.children[i])\n      if(i !== len_minus_one) {\n        output.push(ws.required(' '))\n      }\n    }\n  }\n\n  return\n  if(node.children.length === 2) {\n    deparse(node.children[0])\n    output.push(ws.required(' '))\n    deparse(node.children[1])\n    return\n  }\n\n  if(node.qualified) {\n    deparse(node.children[0]), output.push(ws.required(' '))\n  }\n  deparse(node.children[1])\n  output.push(ws.required(' '))\n  deparse(node.children[2])\n}\n\nfunction deparse_decllist(node) {\n  for(var i = 0, len = node.children.length; i < len; ++i) {\n    if(i > 0) {\n      if(node.children[i].type !== 'ident') {\n        if(node.children[i].type !== 'quantifier') {\n          output.push(ws.optional(' '))\n          output.push('=')\n          output.push(ws.optional(' '))\n        }\n      } else {\n        output.push(',')\n        output.push(ws.optional(' '))\n      }\n    }\n    deparse(node.children[i])\n  }\n}\n\nfunction deparse_discard(node) {\n  output.push('discard')\n}\n\nfunction deparse_do_while(node) {\n  var is_stmtlist = node.children[0].type === 'stmtlist'\n\n  output.push('do')\n  if(is_stmtlist) {\n    output.push(ws.optional(' '))\n  } else {\n    ws.indent()\n    output.push(ws.enabled ? ws.optional('\\n') : ws.required(' '))\n  }\n\n  deparse(node.children[0])\n\n  if(is_stmtlist) {\n    output.push(ws.optional(' '))\n  } else {\n    ws.dedent()\n    output.push(ws.optional('\\n'))\n  }\n  output.push('while(')\n  deparse(node.children[1])\n  output.push(')')\n}\n\nfunction deparse_expr(node) {\n  node.children.length && deparse(node.children[0])\n}\n\nfunction deparse_forloop(node) {\n  var is_stmtlist = node.children[3].type === 'stmtlist' \n\n  output.push('for(')\n  deparse(node.children[0])\n  output.push(';')\n  output.push(ws.optional(' '))\n  deparse(node.children[1])\n  output.push(';')\n  output.push(ws.optional(' '))\n  deparse(node.children[2])\n  output.push(')')\n\n  if(is_stmtlist) {\n    output.push(ws.optional(' '))\n  } else {\n    ws.indent()\n  }\n  deparse(node.children[3])\n  if(!is_stmtlist) {\n    ws.dedent()\n  }\n}\n\nfunction deparse_function(node) {\n  deparse(node.children[0])\n  output.push('(')\n  deparse(node.children[1])\n  output.push(')')\n\n  if(node.children[2]) {\n    output.push(ws.optional(' '))\n    deparse(node.children[2])\n  }\n}\n\nfunction deparse_functionargs(node) {\n  var len = node.children.length\n    , len_minus_one = len - 1\n\n  for(var i = 0; i < len; ++i) {\n    deparse(node.children[i])\n    if(i !== len_minus_one) {\n      output.push(',')\n      output.push(ws.optional(' '))\n    }\n  } \n}\n\nfunction deparse_ident(node) {\n  output.push(node.data)\n}\n\nfunction deparse_if(node) {\n  var needs_indent = true\n  for(var j = 1; j < 4; ++j) {\n    if(output[output.length - j] === 'else') {\n      output.length = output.length - j\n      output.push('else ')\n      break\n    } else if(/[^\\s]/.test(output[output.length - j])) {\n      break\n    }\n  }\n\n  var is_first_stmt = node.children[1].type === 'stmt'\n    , has_second = node.children[2]\n    , is_second_stmt = has_second && node.children[2].children[0].type !== 'stmtlist'\n\n  output.push('if(')\n  deparse(node.children[0])\n  output.push(')')\n\n  if(is_first_stmt) {\n    needs_indent && ws.indent()\n    output.push(ws.enabled ? ws.optional('\\n') : ws.required(' '))\n  } else {\n    output.push(ws.optional(' '))\n  }\n  deparse(node.children[1])\n\n  if(is_first_stmt) {\n    needs_indent && ws.dedent()\n    output.push(ws.optional('\\n'))\n  }\n\n  if(has_second) {\n    var is_if_stmt = node.children[2].children[0].type === 'if'\n\n    if(output[output.length - 1] === '}') {\n      output.push(ws.optional(' '))\n    }\n    output.push('else')\n    if(is_second_stmt) {\n      !is_if_stmt && ws.indent()\n      output.push(ws.enabled ? ws.optional('\\n') : ws.required(' '))\n    } else {\n      output.push(ws.optional(' '))\n    }\n\n    deparse(node.children[2])\n\n    if(is_second_stmt) {\n      !is_if_stmt && ws.dedent()\n      output.push(ws.optional('\\n'))\n    }\n  } \n}\n\nfunction deparse_keyword(node) {\n  output.push(node.token.data)\n}\n\nfunction deparse_literal(node) {\n  output.push(node.data)\n}\n\nfunction deparse_precision(node) {\n  var len = node.children.length\n    , len_minus_one = len - 1\n\n  output.push('precision')\n  output.push(ws.required(' '))\n  for(var i = 0; i < len; ++i) {\n    deparse(node.children[i])\n    if(i !== len_minus_one) {\n      output.push(ws.required(' '))\n    }\n  }\n}\n\nfunction deparse_preprocessor(node) {\n  if(output[output.length - 1] !== '\\n')\n    output.push(ws.required('\\n'))\n  output.push(node.token.data)\n  output.push(ws.required('\\n'))\n}\n\nfunction deparse_return(node) {\n  output.push('return')\n  if(node.children[0]) {\n    output.push(ws.required(' '))\n    deparse(node.children[0])\n  }\n}\n\nfunction deparse_stmt(node) {\n  if(!node.children.length) return\n\n  var has_child = node.children.length > 0\n    , semicolon = has_child ? needs_semicolon[node.children[0].type] : ''\n    , needs_newline = true\n\n  if(has_child && node.children[0].type === 'decl') {\n    if(node.children[0].children.length > 5 && node.children[0].children[5].type === 'function') {\n      semicolon = !node.children[0].children[5].children[2]\n    }\n  }\n\n  if(has_child && node.children[0].type === 'stmtlist') {\n    needs_newline = false\n  }\n\n  var last = output[output.length - 1]\n  if(!last || last.charAt(0) !== '\\n') {\n    needs_newline && output.push(ws.optional('\\n'))\n  }\n\n  deparse(node.children[0])\n  if(semicolon) output.push(';')\n}\n\nfunction deparse_stmtlist(node) {\n  var has_parent = node.parent !== null\n \n  if(has_parent) {\n    output.push('{')\n    ws.indent()\n    output.push(ws.optional('\\n')) \n  }\n\n  for(var i = 0, len = node.children.length; i < len; ++i) {\n    deparse(node.children[i])\n  }\n\n  if(has_parent) {\n    ws.dedent()\n    output.push(ws.optional('\\n'))\n    output.push('}')\n  }\n}\n\nfunction deparse_struct(node) {\n  output.push('struct')\n  output.push(ws.required(' '))\n  deparse(node.children[0])\n  output.push(ws.optional(' '))\n  output.push('{')\n  ws.indent()\n  output.push(ws.optional('\\n'))\n\n  var len = node.children.length\n    , len_minus_one = len - 1\n\n  for(var i = 1, len = node.children.length; i < len; ++i) {\n    deparse(node.children[i])\n    output.push(';')\n    if(i !== len_minus_one) {\n      output.push(ws.optional('\\n'))\n    }\n  }\n\n  ws.dedent()\n  output.push(ws.optional('\\n'))\n  output.push('}')\n}\n\nfunction deparse_assign(node) {\n  deparse(node.children[0])\n  output.push(ws.optional(' '))\n  output.push(node.token.data)\n  output.push(ws.optional(' '))\n  deparse(node.children[1])\n}\n\nfunction deparse_unary(node) {\n  output.push(node.data)\n  deparse(node.children[0])\n}\n\nfunction deparse_whileloop(node) {\n  var is_stmtlist = node.children[1].type === 'stmtlist'\n\n  output.push('while(')\n  deparse(node.children[0])\n  output.push(')')\n  output.push(is_stmtlist ? ws.optional(' ') : ws.required(' '))\n  deparse(node.children[1])\n}\n\nfunction deparse_call(node) {\n  var len = node.children.length\n    , len_minus_one = len - 1\n  \n  deparse(node.children[0])\n  output.push('(')\n  for(var i = 1; i < len; ++i) {\n    deparse(node.children[i])\n    if(i !== len_minus_one) {\n      output.push(',')\n      output.push(ws.optional(' '))\n    }\n  }\n  output.push(')')  \n}\n\nfunction deparse_operator(node) {\n  deparse(node.children[0])\n  output.push(node.data)\n  deparse(node.children[1])\n}\n\nfunction deparse_group(node) {\n  output.push('(')\n  deparse(node.children[0])\n  output.push(')')\n}\n\nfunction deparse_quantifier(node) {\n  output.push('[')\n  if(node.children[0]) deparse(node.children[0])\n  output.push(']')\n}\n\nfunction deparse_ternary(node) {\n  deparse(node.children[0])\n  output.push(ws.optional(' '))\n  output.push('?')\n  output.push(ws.optional(' '))\n  deparse(node.children[1])\n  output.push(ws.optional(' '))\n  output.push(':')\n  output.push(ws.optional(' '))\n  deparse(node.children[2])\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-deparser/lib/index.js?");

/***/ }),

/***/ "./node_modules/glsl-deparser/lib/ws.js":
/*!**********************************************!*\
  !*** ./node_modules/glsl-deparser/lib/ws.js ***!
  \**********************************************/
/***/ ((module) => {

eval("module.exports = Manager\n\nvar Nothing = ''\n\nfunction Manager(whitespace_enabled, indent_text) {\n  this.enabled = whitespace_enabled\n  this.indent_text = indent_text\n  this.level = 0\n  this.tabcache = [\n      ''\n    , indent_text\n    , indent_text + indent_text\n    , indent_text + indent_text + indent_text\n  ]\n\n  this.optional = whitespace_enabled ? this.required : this.disabled\n}\n\nvar cons = Manager\n  , proto = cons.prototype\n\nproto.indent = function() {\n  ++this.level\n}\n\nproto.dedent = function() {\n  --this.level\n}\n\nproto.disabled = function() {\n  return Nothing\n}\n\nproto.required = function(c) {\n  if(c === '\\n' && this.enabled) {\n    c += this.tab()\n  }\n  return c\n}\n\nproto.tab = function() {\n  // yes, we're caching tabs.\n  // why? well, every line is going to be calling this,\n  // which would suck if we were indented a bunch in a block.\n  if(this.tabcache[this.level]) {\n    return this.tabcache[this.level]\n  }\n\n  var _ = ''\n  for(var i = 0, len = this.level, o = this.indent_text; i < len; ++i) {\n    _ += o\n  }\n\n  return this.tabcache[len] = _\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-deparser/lib/ws.js?");

/***/ }),

/***/ "./node_modules/glsl-deparser/node_modules/through/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/glsl-deparser/node_modules/through/index.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\nvar Stream = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\")\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\n\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end) {\n  write = write || function (data) { this.emit('data', data) }\n  end = end || function () { this.emit('end') }\n\n  var ended = false, destroyed = false\n  var stream = new Stream(), buffer = []\n  stream.buffer = buffer\n  stream.readable = stream.writable = true\n  stream.paused = false\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = function (data) {\n    buffer.push(data)\n    drain()\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    stream.emit('pause')\n  }\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n  }\n  return stream\n}\n\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-deparser/node_modules/through/index.js?");

/***/ }),

/***/ "./node_modules/glsl-extract-sync/index.js":
/*!*************************************************!*\
  !*** ./node_modules/glsl-extract-sync/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\nvar extract = __webpack_require__(/*! glsl-extract */ \"./node_modules/glsl-extract/index.js\")\nvar through = __webpack_require__(/*! through */ \"./node_modules/through/index.js\")\n\nmodule.exports = getExports\n\n//This is a horrible hack to make streams run synchronously\nfunction getExports(source) {\n  var exports\n  var stream = through()\n  var nextTick = process.nextTick\n  var stack = []\n  process.nextTick = function(f) {\n    stack.push(f)\n  }\n\n  extract(stream)(function onExtractComplete(err, info) {\n    if(err) {\n      throw err\n    }\n    exports = info\n  })\n\n  stream.end(source)\n\n  for(var i=0; i<stack.length; ++i) {\n    var f = stack[i]\n    try {\n      f()\n    } catch(e) {\n      console.error(e)\n    }\n  }\n  process.nextTick = nextTick\n  return exports\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-extract-sync/index.js?");

/***/ }),

/***/ "./node_modules/glsl-extract/index.js":
/*!********************************************!*\
  !*** ./node_modules/glsl-extract/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n\n\nmodule.exports = extract\n\nvar tokenizer = __webpack_require__(/*! glsl-tokenizer */ \"./node_modules/glsl-tokenizer/index.js\")\n  , utf8stream = __webpack_require__(/*! utf8-stream */ \"./node_modules/utf8-stream/index.js\")\n  , parser = __webpack_require__(/*! glsl-parser */ \"./node_modules/glsl-parser/index.js\")\n  , through = __webpack_require__(/*! through */ \"./node_modules/through/index.js\")\n\nvar preprocess = __webpack_require__(/*! ./lib/preprocess */ \"./node_modules/glsl-extract/lib/preprocess.js\")\n\nvar collect = __webpack_require__(/*! ./lib/collect */ \"./node_modules/glsl-extract/lib/collect.js\")\n  , format = __webpack_require__(/*! ./lib/format */ \"./node_modules/glsl-extract/lib/format.js\")\n\nfunction extract(program, getcontext) {\n  if(typeof program === 'string') {\n    program = string_to_stream(program)\n  }\n\n  if(arguments.length < 2) {\n    getcontext = function(ctxt) {\n      return parseInt(ctxt)\n    }\n  }\n\n  var pause = through()\n\n  pause.pause()\n  program.pipe(pause)\n\n  return continuable\n\n  function continuable(ready) {\n    var attributes = []\n      , uniforms = []\n      , structs = {}\n\n    pause\n      .pipe(utf8stream())\n      .pipe(tostring())\n      .pipe(tokenizer())\n      .pipe(preprocess(getcontext))\n      .pipe(parser())\n      .pipe(collect(structs, uniforms, attributes))\n      .pipe(through(null, output_all))\n\n    pause.resume()\n\n    function output_all() {\n      try {\n        ready(null, {\n            uniforms: format(uniforms, structs)\n          , attributes: format(attributes, structs)\n        })\n      } catch(err) {\n        ready(err)\n      }\n    }\n  }\n}\n\nfunction string_to_stream(str) {\n  var stream = through()\n\n  process.nextTick(function() {\n    stream.end(Buffer.isBuffer(str) ? str : new Buffer(str, 'utf8'))\n  })\n\n  return stream\n}\n\nfunction tostring() {\n  var stream = through(write)\n\n  return stream\n\n  function write(buf) {\n    stream.queue(buf.toString('utf8'))\n  }\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-extract/index.js?");

/***/ }),

/***/ "./node_modules/glsl-extract/lib/collect.js":
/*!**************************************************!*\
  !*** ./node_modules/glsl-extract/lib/collect.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = collect_storages\n\nvar lang = __webpack_require__(/*! cssauron-glsl */ \"./node_modules/cssauron-glsl/index.js\")\n  , through = __webpack_require__(/*! through */ \"./node_modules/through/index.js\")\n\nvar check_storage = lang(':root > stmt > decl')\n  , is_struct = lang('stmt > decl > struct')\n\nfunction collect_storages(structs, uniforms, attributes) {\n  var stream = through(write)\n\n  return stream\n\n  function write(node) {\n    if(node.type === 'ident') {\n      return\n    }\n\n    if(is_struct(node)) {\n      if(node.children[0].type === 'ident' && node.children[0].data) {\n        structs[node.children[0].data] = node\n      }\n    }\n\n    if(!check_storage(node)) {\n      return\n    }\n\n    var type = node.children[1].token.data\n\n    if(type === 'uniform') {\n      uniforms.push(node)\n    } else if(type === 'attribute') {\n      attributes.push(node)\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-extract/lib/collect.js?");

/***/ }),

/***/ "./node_modules/glsl-extract/lib/deparse.js":
/*!**************************************************!*\
  !*** ./node_modules/glsl-extract/lib/deparse.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = deparse\n\nvar deparser = __webpack_require__(/*! glsl-deparser */ \"./node_modules/glsl-deparser/index.js\")\n  , through = __webpack_require__(/*! through */ \"./node_modules/through/index.js\")\n\nfunction deparse(node) {\n  var stream = deparser()\n    , output\n    , tmp\n\n  // this mutates the node.\n\n  tmp = node.parent\n  node.parent = {}\n\n  stream.pipe(through(write))\n  stream.end(node)\n\n  return Function('return ' + output)()\n\n  function write(data) {\n    output = data\n  }\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-extract/lib/deparse.js?");

/***/ }),

/***/ "./node_modules/glsl-extract/lib/format.js":
/*!*************************************************!*\
  !*** ./node_modules/glsl-extract/lib/format.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = format\n\nvar deparse = __webpack_require__(/*! ./deparse */ \"./node_modules/glsl-extract/lib/deparse.js\")\n\nfunction format(items, struct_info, path, output) {\n  output = output || []\n\n  path = path || []\n\n  for(var i = 0, len = items.length; i < len; ++i) {\n    format_item_into(\n        items[i]\n      , struct_info\n      , path\n      , output\n    )\n  }\n\n  return output\n}\n\nfunction format_item_into(decl_node, struct_info, path, output) {\n  var children = decl_node.children\n\n  var is_invariant = children[0].token.data === 'invariant'\n    , parameter = children[2].token.data\n    , type = children[4].token.data\n    , names = []\n\n  names = children[5].children.reduce(roll_quantifiers_into_names, [])\n\n  if(children[4].type === 'keyword') {\n    for(var i = 0, len = names.length; i < len; ++i) {\n      if(!names[i].quantifier) {\n        output[output.length] = {\n            name: path.concat([names[i].data]).join('.')\n          , type: type\n        }\n\n        continue\n      }\n\n      var quant = +deparse(names[i].quantifier)\n\n      if(isNaN(quant)) {\n        throw new Error('could not quantify ' + names[i].data)\n      }\n\n      for(var j = 0; j < quant; ++j) {\n        output[output.length] = {\n            name: path.concat([names[i].data + '[' + j + ']']).join('.')\n          , type: type\n        }\n      }\n    }\n\n    return\n  }\n\n  var struct = type === 'struct' ? children[4] : struct_info[type]\n    , children\n\n  if(!struct) {\n    throw new Error('unrecognized user type ' + type)\n  }\n\n  children = struct.children.filter(function(x) {\n    return x.type === 'decl'\n  })\n\n  for(var i = 0, len = names.length; i < len; ++i) {\n    if(!names[i].quantifier) {\n      path.push(names[i].data)\n\n      format(\n          children\n        , struct_info\n        , path\n        , output\n      )\n      path.pop()\n\n      continue\n    }\n\n    var quant = +deparse(names[i].quantifier)\n\n    if(isNaN(quant)) {\n      throw new Error('could not quantify ' + names[i].data)\n    }\n\n    var out = []\n\n    format(\n        children\n      , struct_info\n      , []\n      , out\n    )\n\n    for(var x = 0; x < out.length; ++x) {\n      for(var j = 0; j < quant; ++j) {\n        output[output.length] = {\n            name: path.concat([\n                names[i].data + '[' + j + ']'\n              , out[x].name\n            ]).join('.')\n          , type: out[x].type\n        }\n      }\n    }\n  }\n}\n\nfunction roll_quantifiers_into_names(lhs, rhs) {\n  if(rhs.token.data === '[') {\n    lhs[lhs.length - 1].quantifier = rhs.children[0]\n  } else {\n    lhs[lhs.length] = rhs\n  }\n\n  return lhs\n}\n\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-extract/lib/format.js?");

/***/ }),

/***/ "./node_modules/glsl-extract/lib/preprocess.js":
/*!*****************************************************!*\
  !*** ./node_modules/glsl-extract/lib/preprocess.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = preprocess\n\nvar tokenizer = __webpack_require__(/*! glsl-tokenizer */ \"./node_modules/glsl-tokenizer/index.js\")\n  , parser = __webpack_require__(/*! glsl-parser */ \"./node_modules/glsl-parser/index.js\")\n  , through = __webpack_require__(/*! through */ \"./node_modules/through/index.js\")\n\nvar REPLACE = 0\n  , MACRO = 1\n\nfunction preprocess(_getctx) {\n  var stream = through(write)\n    , registry = {}\n\n  var $state = $init\n    , collected = []\n    , paren_lvl = 0\n    , if_lvl = 0\n    , macro_call\n\n  return stream\n\n  function write(token) {\n    $state = $state(token)\n  }\n\n  function getctx(str) {\n    var ret = _getctx(str)\n\n    if(ret === null || ret === undefined) {\n      return ret\n    }\n\n    return {text: ret + ''}\n  }\n\n  function define_macro(match) {\n    var name = match[1]\n      , args = match[2]\n      , as = match[3]\n\n    as = as\n      .replace(/^\\s+/, '')\n      .replace(/\\s+$/, '')\n\n    args = args.split(',').map(function(xs) {\n      return xs\n        .replace(/^\\s+/, '')\n        .replace(/\\s+$/, '')\n    })\n\n    registry[name] = {\n        type: MACRO\n      , text: as\n      , args: args\n    }\n  }\n\n  function define_replace(match) {\n    var name = match[1]\n      , as = match[2]\n\n    as = as\n      .replace(/^\\s+/, '')\n      .replace(/\\s+$/, '')\n\n    registry[name] = {\n        type: REPLACE\n      , text: as\n    }\n  }\n\n  function $init(token) {\n    var injector\n      , value\n\n    if(token.type === 'ident') {\n      value = registry[token.data]\n\n      value = value ||\n        (token.data.slice(0, 3) === 'GL_' ? getctx(token.data) : null)\n\n      if(value) {\n        if(value.type === MACRO) {\n          macro_call = value\n\n          return $await_call\n        }\n\n        injector = tokenizer()\n\n        injector\n          .on('data', inject_token)\n          .on('error', onerror)\n          .end(value.text)\n\n        return $state\n      }\n\n    }\n\n    if(token.type === 'preprocessor') {\n      return onpreprocessor(token)\n    }\n\n    stream.queue(token)\n\n    return $state\n  }\n\n  function $ignore_until_endif(token) {\n    if(token.type === 'eof') {\n      stream.emit('error', new Error('unexpected eof'))\n    }\n\n    if(token.type !== 'preprocessor') {\n      return $state\n    }\n\n    if(/^#\\s*endif/.test(token.data)) {\n      return !--if_lvl ? $init : $state\n    }\n\n    if(/^#\\s*if/.test(token.data)) {\n      ++if_lvl\n    }\n\n    return $state\n  }\n\n  function $ignore_until_alternate(token) {\n    if(token.type === 'eof') {\n      stream.emit('error', new Error('unexpected eof'))\n    }\n\n    if(token.type !== 'preprocessor') {\n      return $state\n    }\n\n    if(/^#\\s*endif/.test(token.data)) {\n      return !--if_lvl ? $init : $state\n    }\n\n    if(/^#\\s*elif/.test(token.data) && if_lvl === 1) {\n      var inject = tokenizer()\n        , result\n        , rest\n\n      rest = token.data.replace(/^#\\s*elif\\s*/, '')\n\n\n      inject\n        .pipe(defined_to_op())\n        .pipe(parser())\n      .on('data', function(node) {\n        if(!node.parent) {\n          result = node\n        }\n      })\n      inject.end(rest + ';')\n\n      if(!!if_eval(result)) {\n        return $init\n      }\n\n      return $ignore_until_alternate\n    }\n\n    if(/^#\\s*else/.test(token.data) && if_lvl === 1) {\n      return $init\n    }\n\n    if(/^#\\s*if/.test(token.data)) {\n      ++if_lvl\n\n      return $state\n    }\n\n    return $state\n  }\n\n  function $await_call(token) {\n    if(token.data === '(') {\n      paren_lvl = 1\n      collected = [[]]\n\n      return $collect\n    }\n\n    stream.queue(token)\n\n    return $init\n  }\n\n  function $collect(token) {\n    if(token.data === '(') {\n      ++paren_lvl\n    }\n\n    if(token.data === ')') {\n      --paren_lvl\n    }\n\n    if(token.data === ',' && paren_lvl === 1) {\n      collected[collected.length] = []\n    }\n\n    if(!paren_lvl) {\n      $state = $init\n\n      var injector = tokenizer()\n\n      injector\n        .on('data', macro_inject_token)\n        .on('error', onerror)\n        .end(macro_call.text)\n\n      return $state\n    }\n\n    collected[collected.length - 1].push(token)\n\n    return $collect\n  }\n\n  function onerror(err) {\n    stream.emit('error', err)\n  }\n\n  function macro_inject_token(token) {\n    if(token.type === 'eof') {\n      return\n    }\n\n    if(token.type !== 'ident') {\n      return write(token)\n    }\n\n    var idx = macro_call.args.indexOf(token.data)\n      , output\n\n    if(idx === -1) {\n      return write(token)\n    }\n\n    output = collected[idx].slice()\n\n    while(output.length) {\n      write(output.shift())\n    }\n  }\n\n  function inject_token(token) {\n    if(token.type === undefined) {\n      token.type = 'ident'\n    }\n\n    if(token.type === 'eof') {\n      return\n    }\n\n    write(token)\n  }\n\n  function onpreprocessor(token) {\n    var bits = token.data.replace(/^#\\s*/, '').split(' ')\n      , directive = bits[0]\n      , rest\n\n    rest = bits.slice(1).join(' ')\n      .replace(/^\\s+/, '')\n      .replace(/\\s+$/, '')\n\n    if(directive === 'define') {\n      var match = /^([\\w\\d_]+)\\(([^)]+)\\)\\s(.*)$/.exec(rest)\n\n      if(match) {\n        define_macro(match)\n\n        return $init\n      }\n\n      match = /^([\\w\\d_]+)(.*)$/.exec(rest)\n\n      if(!match) {\n        stream.emit('error', new Error('cannot parse #define'))\n\n        return $init\n      }\n\n      define_replace(match)\n\n      return $init\n    }\n\n    if(directive === 'undef') {\n      delete registry[rest]\n\n      return $init\n    }\n\n    if(directive === 'endif') {\n      return $init\n    }\n\n    if(directive === 'else' || directive === 'elif') {\n      if_lvl = 1\n\n      return $ignore_until_endif\n    }\n\n    if(directive.slice(0, 2) !== 'if') {\n      return $state\n    }\n\n    if_lvl = 1\n\n    if(directive === 'ifdef') {\n      return rest in registry ? $state : $ignore_until_alternate\n    }\n\n    if(directive === 'ifndef') {\n      return !(rest in registry) ? $state : $ignore_until_alternate\n    }\n\n    var inject = tokenizer()\n      , result\n\n    inject\n      .pipe(defined_to_op())\n      .pipe(parser())\n    .on('data', function(node) {\n      if(!node.parent) {\n        result = node\n      }\n    })\n    inject.end(rest + ';')\n\n    return !!if_eval(result) ? $state : $ignore_until_alternate\n  }\n\n  // tiny runtime:\n  function if_eval(node) {\n    if(node.type === 'ident') {\n      return (registry[node.token.data] || getctx(node.token.data) || {}).text\n    }\n\n    if(node.type === 'literal') {\n      return node.token.data === 'true' ? true :\n            node.token.data === 'false' ? false :\n            node.token.data | 0\n    }\n\n    if(node.type !== 'binary' && node.type !== 'unary') {\n      return node.children.every(if_eval)\n    }\n\n    var children = node.children || []\n      , lhs = children[0]\n      , rhs = children[1]\n      , _ = if_eval\n\n    if(node.type === 'unary') {\n      switch(node.token.data) {\n        case 'defined': return !!(lhs.token.data in registry)\n        case '+': return +_(lhs)\n        case '-': return -_(lhs)\n        case '~': return ~_(lhs)\n        case '!': return !_(lhs)\n        case '(': return _(lhs)\n      }\n    }\n\n    switch(node.token.data) {\n      case '+':   return _(lhs) + _(rhs)\n      case '-':   return _(lhs) - _(rhs)\n      case '^':   return _(lhs) ^ _(rhs)\n      case '*':   return _(lhs) * _(rhs)\n      case '/':   return _(lhs) / _(rhs)\n      case '%':   return _(lhs) % _(rhs)\n      case '>>':  return _(lhs) >> _(rhs)\n      case '<<':  return _(lhs) << _(rhs)\n      case '<':   return _(lhs) < _(rhs)\n      case '>':   return _(lhs) > _(rhs)\n      case '<=':  return _(lhs) <= _(rhs)\n      case '>=':  return _(lhs) >= _(rhs)\n      case '==':  return _(lhs) === _(rhs)\n      case '!=':  return _(lhs) !== _(rhs)\n      case '|':   return _(lhs) | _(rhs)\n      case '||':  return _(lhs) || _(rhs)\n      case '&':   return _(lhs) & _(rhs)\n      case '&&':  return _(lhs) && _(rhs)\n    }\n  }\n}\n\nfunction defined_to_op() {\n  return through(function(token) {\n    if(token.type === 'ident' && token.data === 'defined') {\n      token.type = 'operator'\n    }\n\n    this.queue(token)\n  })\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-extract/lib/preprocess.js?");

/***/ }),

/***/ "./node_modules/glsl-parser/index.js":
/*!*******************************************!*\
  !*** ./node_modules/glsl-parser/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/index */ \"./node_modules/glsl-parser/lib/index.js\")\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-parser/index.js?");

/***/ }),

/***/ "./node_modules/glsl-parser/lib/expr.js":
/*!**********************************************!*\
  !*** ./node_modules/glsl-parser/lib/expr.js ***!
  \**********************************************/
/***/ ((module) => {

eval("var state\n  , token\n  , tokens\n  , idx\n\nvar original_symbol = {\n    nud: function() { return this.children && this.children.length ? this : fail('unexpected')() }\n  , led: fail('missing operator')\n}\n\nvar symbol_table = {}\n\nfunction itself() {\n  return this\n}\n\nsymbol('(ident)').nud = itself\nsymbol('(keyword)').nud = itself\nsymbol('(builtin)').nud = itself\nsymbol('(literal)').nud = itself\nsymbol('(end)')\n\nsymbol(':')\nsymbol(';')\nsymbol(',')\nsymbol(')')\nsymbol(']')\nsymbol('}')\n\ninfixr('&&', 30)\ninfixr('||', 30)\ninfix('|', 43)\ninfix('^', 44)\ninfix('&', 45)\ninfix('==', 46)\ninfix('!=', 46)\ninfix('<', 47)\ninfix('<=', 47)\ninfix('>', 47)\ninfix('>=', 47)\ninfix('>>', 48)\ninfix('<<', 48)\ninfix('+', 50)\ninfix('-', 50)\ninfix('*', 60)\ninfix('/', 60)\ninfix('%', 60)\ninfix('?', 20, function(left) {\n  this.children = [left, expression(0), (advance(':'), expression(0))]\n  this.type = 'ternary'\n  return this\n})\ninfix('.', 80, function(left) {\n  token.type = 'literal'\n  state.fake(token)\n  this.children = [left, token]\n  advance()\n  return this\n})\ninfix('[', 80, function(left) {\n  this.children = [left, expression(0)]\n  this.type = 'binary'\n  advance(']')\n  return this\n})\ninfix('(', 80, function(left) {\n  this.children = [left]\n  this.type = 'call'\n\n  if(token.data !== ')') while(1) {\n    this.children.push(expression(0))\n    if(token.data !== ',') break\n    advance(',')\n  }\n  advance(')')\n  return this\n})\n\nprefix('-')\nprefix('+')\nprefix('!')\nprefix('~')\nprefix('defined')\nprefix('(', function() {\n  this.type = 'group'\n  this.children = [expression(0)]\n  advance(')')\n  return this \n})\nprefix('++')\nprefix('--')\nsuffix('++')\nsuffix('--')\n\nassignment('=')\nassignment('+=')\nassignment('-=')\nassignment('*=')\nassignment('/=')\nassignment('%=')\nassignment('&=')\nassignment('|=')\nassignment('^=')\nassignment('>>=')\nassignment('<<=')\n\nmodule.exports = function(incoming_state, incoming_tokens) {\n  state = incoming_state\n  tokens = incoming_tokens\n  idx = 0\n  var result\n\n  if(!tokens.length) return\n\n  advance()\n  result = expression(0)\n  result.parent = state[0]\n  emit(result)\n\n  if(idx < tokens.length) {\n    throw new Error('did not use all tokens')\n  }\n\n  result.parent.children = [result]\n\n  function emit(node) {\n    state.unshift(node, false)\n    for(var i = 0, len = node.children.length; i < len; ++i) {\n      emit(node.children[i])\n    }\n    state.shift()\n  }\n\n}\n\nfunction symbol(id, binding_power) {\n  var sym = symbol_table[id]\n  binding_power = binding_power || 0\n  if(sym) {\n    if(binding_power > sym.lbp) {\n      sym.lbp = binding_power\n    }\n  } else {\n    sym = Object.create(original_symbol)\n    sym.id = id \n    sym.lbp = binding_power\n    symbol_table[id] = sym\n  }\n  return sym\n}\n\nfunction expression(rbp) {\n  var left, t = token\n  advance()\n\n  left = t.nud()\n  while(rbp < token.lbp) {\n    t = token\n    advance()\n    left = t.led(left)\n  }\n  return left\n}\n\nfunction infix(id, bp, led) {\n  var sym = symbol(id, bp)\n  sym.led = led || function(left) {\n    this.children = [left, expression(bp)]\n    this.type = 'binary'\n    return this\n  }\n}\n\nfunction infixr(id, bp, led) {\n  var sym = symbol(id, bp)\n  sym.led = led || function(left) {\n    this.children = [left, expression(bp - 1)]\n    this.type = 'binary'\n    return this\n  }\n  return sym\n}\n\nfunction prefix(id, nud) {\n  var sym = symbol(id)\n  sym.nud = nud || function() {\n    this.children = [expression(70)]\n    this.type = 'unary'\n    return this\n  }\n  return sym\n}\n\nfunction suffix(id) {\n  var sym = symbol(id, 150)\n  sym.led = function(left) {\n    this.children = [left]\n    this.type = 'suffix'\n    return this\n  }\n}\n\nfunction assignment(id) {\n  return infixr(id, 10, function(left) {\n    this.children = [left, expression(9)]\n    this.assignment = true\n    this.type = 'assign'\n    return this\n  })\n}\n\nfunction advance(id) {\n  var next\n    , value\n    , type\n    , output\n\n  if(id && token.data !== id) {\n    return state.unexpected('expected `'+ id + '`, got `'+token.data+'`')\n  }\n\n  if(idx >= tokens.length) {\n    token = symbol_table['(end)']\n    return\n  }\n\n  next = tokens[idx++]\n  value = next.data\n  type = next.type\n\n  if(type === 'ident') {\n    output = state.scope.find(value) || state.create_node()\n    type = output.type\n  } else if(type === 'builtin') {\n    output = symbol_table['(builtin)']\n  } else if(type === 'keyword') {\n    output = symbol_table['(keyword)']\n  } else if(type === 'operator') {\n    output = symbol_table[value]\n    if(!output) {\n      return state.unexpected('unknown operator `'+value+'`')\n    }\n  } else if(type === 'float' || type === 'integer') {\n    type = 'literal'\n    output = symbol_table['(literal)']\n  } else {\n    return state.unexpected('unexpected token.')\n  }\n\n  if(output) {\n    if(!output.nud) { output.nud = itself }\n    if(!output.children) { output.children = [] }\n  }\n\n  output = Object.create(output)\n  output.token = next\n  output.type = type\n  if(!output.data) output.data = value\n\n  return token = output\n}\n\nfunction fail(message) {\n  return function() { return state.unexpected(message) }\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-parser/lib/expr.js?");

/***/ }),

/***/ "./node_modules/glsl-parser/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/glsl-parser/lib/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = parser\n\nvar through = __webpack_require__(/*! through */ \"./node_modules/glsl-parser/node_modules/through/index.js\")\n  , full_parse_expr = __webpack_require__(/*! ./expr */ \"./node_modules/glsl-parser/lib/expr.js\")\n  , Scope = __webpack_require__(/*! ./scope */ \"./node_modules/glsl-parser/lib/scope.js\")\n\n// singleton!\nvar Advance = new Object\n\nvar DEBUG = false\n\nvar _ = 0\n  , IDENT = _++\n  , STMT = _++\n  , STMTLIST = _++\n  , STRUCT = _++\n  , FUNCTION = _++\n  , FUNCTIONARGS = _++\n  , DECL = _++\n  , DECLLIST = _++\n  , FORLOOP = _++\n  , WHILELOOP = _++\n  , IF = _++\n  , EXPR = _++\n  , PRECISION = _++\n  , COMMENT = _++\n  , PREPROCESSOR = _++\n  , KEYWORD = _++\n  , KEYWORD_OR_IDENT = _++\n  , RETURN = _++\n  , BREAK = _++\n  , CONTINUE = _++\n  , DISCARD = _++\n  , DOWHILELOOP = _++\n  , PLACEHOLDER = _++\n  , QUANTIFIER = _++\n\nvar DECL_ALLOW_ASSIGN = 0x1\n  , DECL_ALLOW_COMMA = 0x2\n  , DECL_REQUIRE_NAME = 0x4\n  , DECL_ALLOW_INVARIANT = 0x8\n  , DECL_ALLOW_STORAGE = 0x10\n  , DECL_NO_INOUT = 0x20\n  , DECL_ALLOW_STRUCT = 0x40\n  , DECL_STATEMENT = 0xFF\n  , DECL_FUNCTION = DECL_STATEMENT & ~(DECL_ALLOW_ASSIGN | DECL_ALLOW_COMMA | DECL_NO_INOUT | DECL_ALLOW_INVARIANT | DECL_REQUIRE_NAME)\n  , DECL_STRUCT = DECL_STATEMENT & ~(DECL_ALLOW_ASSIGN | DECL_ALLOW_INVARIANT | DECL_ALLOW_STORAGE | DECL_ALLOW_STRUCT)\n\nvar QUALIFIERS = ['const', 'attribute', 'uniform', 'varying']\n\nvar NO_ASSIGN_ALLOWED = false\n  , NO_COMMA_ALLOWED = false\n\n// map of tokens to stmt types\nvar token_map = {\n    'block-comment': COMMENT\n  , 'line-comment': COMMENT\n  , 'preprocessor': PREPROCESSOR\n}\n\n// map of stmt types to human\nvar stmt_type = _ = [ \n    'ident'\n  , 'stmt'\n  , 'stmtlist'\n  , 'struct'\n  , 'function'\n  , 'functionargs'\n  , 'decl'\n  , 'decllist'\n  , 'forloop'\n  , 'whileloop'\n  , 'if'\n  , 'expr'\n  , 'precision'\n  , 'comment'\n  , 'preprocessor'\n  , 'keyword'\n  , 'keyword_or_ident'\n  , 'return'\n  , 'break'\n  , 'continue'\n  , 'discard'\n  , 'do-while'\n  , 'placeholder'\n  , 'quantifier'\n]\n\nfunction parser() {\n  var stmtlist = n(STMTLIST)\n    , stmt = n(STMT)\n    , decllist = n(DECLLIST)\n    , precision = n(PRECISION)\n    , ident = n(IDENT)\n    , keyword_or_ident = n(KEYWORD_OR_IDENT)\n    , fn = n(FUNCTION)\n    , fnargs = n(FUNCTIONARGS)\n    , forstmt = n(FORLOOP)\n    , ifstmt = n(IF)\n    , whilestmt = n(WHILELOOP)\n    , returnstmt = n(RETURN)\n    , dowhilestmt = n(DOWHILELOOP)\n    , quantifier = n(QUANTIFIER)\n\n  var parse_struct\n    , parse_precision\n    , parse_quantifier\n    , parse_forloop\n    , parse_if\n    , parse_return\n    , parse_whileloop\n    , parse_dowhileloop\n    , parse_function\n    , parse_function_args\n\n  var stream = through(write, end)\n    , check = arguments.length ? [].slice.call(arguments) : []\n    , depth = 0\n    , state = []\n    , tokens = []\n    , whitespace = []\n    , errored = false\n    , program\n    , token\n    , node\n\n  // setup state\n  state.shift = special_shift\n  state.unshift = special_unshift\n  state.fake = special_fake\n  state.unexpected = unexpected\n  state.scope = new Scope(state)\n  state.create_node = function() {\n    var n = mknode(IDENT, token)\n    n.parent = stream.program\n    return n\n  }\n\n  setup_stative_parsers()\n\n  // setup root node\n  node = stmtlist()\n  node.expecting = '(eof)'\n  node.mode = STMTLIST\n  node.token = {type: '(program)', data: '(program)'}\n  program = node\n\n  stream.program = program\n  stream.scope = function(scope) {\n    if(arguments.length === 1) {\n      state.scope = scope\n    }\n    return state.scope\n  }\n\n  state.unshift(node)\n  return stream\n\n  // stream functions ---------------------------------------------\n\n  function write(input) {\n    if(input.type === 'whitespace' || input.type === 'line-comment' || input.type === 'block-comment') {\n\n      whitespace.push(input)\n      return\n    }\n    tokens.push(input)\n    token = token || tokens[0]\n\n    if(token && whitespace.length) {\n      token.preceding = token.preceding || []\n      token.preceding = token.preceding.concat(whitespace)\n      whitespace = []\n    }\n\n    while(take()) switch(state[0].mode) {\n      case STMT: parse_stmt(); break\n      case STMTLIST: parse_stmtlist(); break\n      case DECL: parse_decl(); break\n      case DECLLIST: parse_decllist(); break\n      case EXPR: parse_expr(); break\n      case STRUCT: parse_struct(true, true); break\n      case PRECISION: parse_precision(); break\n      case IDENT: parse_ident(); break\n      case KEYWORD: parse_keyword(); break\n      case KEYWORD_OR_IDENT: parse_keyword_or_ident(); break\n      case FUNCTION: parse_function(); break\n      case FUNCTIONARGS: parse_function_args(); break\n      case FORLOOP: parse_forloop(); break\n      case WHILELOOP: parse_whileloop(); break\n      case DOWHILELOOP: parse_dowhileloop(); break\n      case RETURN: parse_return(); break\n      case IF: parse_if(); break\n      case QUANTIFIER: parse_quantifier(); break\n    }\n  }\n  \n  function end(tokens) {\n    if(arguments.length) {\n      write(tokens)\n    }\n\n    if(state.length > 1) {\n      unexpected('unexpected EOF')\n      return\n    }\n\n    stream.emit('end')\n  }\n\n  function take() {\n    if(errored || !state.length)\n      return errored\n\n    return (token = tokens[0]) && !stream.paused\n  }\n\n  // ----- state manipulation --------\n\n  function special_fake(x) {\n    state.unshift(x)\n    state.shift()\n  }\n\n  function special_unshift(_node, add_child) {\n    _node.parent = state[0]\n\n    var ret = [].unshift.call(this, _node)\n\n    add_child = add_child === undefined ? true : add_child\n\n    if(DEBUG) {\n      var pad = ''\n      for(var i = 0, len = this.length - 1; i < len; ++i) {\n        pad += ' |'\n      }\n      console.log(pad, '\\\\'+_node.type, _node.token.data)\n    }\n\n    if(add_child && node !== _node) node.children.push(_node)\n    node = _node\n\n    return ret\n  }\n\n  function special_shift() {\n    var _node = [].shift.call(this)\n      , okay = check[this.length]\n      , emit = false\n\n    if(DEBUG) {\n      var pad = ''\n      for(var i = 0, len = this.length; i < len; ++i) {\n        pad += ' |'\n      }\n      console.log(pad, '/'+_node.type)\n    }\n\n    if(check.length) { \n      if(typeof check[0] === 'function') {\n        emit = check[0](_node)\n      } else if(okay !== undefined) {\n        emit = okay.test ? okay.test(_node.type) : okay === _node.type\n      }\n    } else {\n      emit = true\n    }\n\n    if(emit) stream.emit('data', _node) \n  \n    node = _node.parent\n    return _node\n  }\n\n  // parse states ---------------\n\n  function parse_stmtlist() {\n    // determine the type of the statement\n    // and then start parsing\n    return stative(\n      function() { state.scope.enter(); return Advance }\n    , normal_mode\n    )()\n\n    function normal_mode() {\n      if(token.data === state[0].expecting) {\n        return state.scope.exit(), state.shift()\n      }\n      switch(token.type) {\n        case 'preprocessor':\n          state.fake(adhoc())\n          tokens.shift()\n        return\n        default:\n          state.unshift(stmt())\n        return \n      }\n    }\n  }\n\n  function parse_stmt() {\n    if(state[0].brace) {\n      if(token.data !== '}') {\n        return unexpected('expected `}`, got '+token.data)\n      }\n      state[0].brace = false\n      return tokens.shift(), state.shift()\n    }\n    switch(token.type) {\n      case 'eof': return state.shift()\n      case 'keyword': \n        switch(token.data) {\n          case 'for': return state.unshift(forstmt());\n          case 'if': return state.unshift(ifstmt());\n          case 'while': return state.unshift(whilestmt());\n          case 'do': return state.unshift(dowhilestmt());\n          case 'break': return state.fake(mknode(BREAK, token)), tokens.shift()\n          case 'continue': return state.fake(mknode(CONTINUE, token)), tokens.shift()\n          case 'discard': return state.fake(mknode(DISCARD, token)), tokens.shift()\n          case 'return': return state.unshift(returnstmt());\n          case 'precision': return state.unshift(precision());\n        }\n        return state.unshift(decl(DECL_STATEMENT))\n      case 'ident':\n        var lookup\n        if(lookup = state.scope.find(token.data)) {\n          if(lookup.parent.type === 'struct') {\n            // this is strictly untrue, you could have an\n            // expr that starts with a struct constructor.\n            //      ... sigh\n            return state.unshift(decl(DECL_STATEMENT))\n          }\n          return state.unshift(expr(';'))\n        }\n      case 'operator':\n        if(token.data === '{') {\n          state[0].brace = true\n          var n = stmtlist()\n          n.expecting = '}'\n          return tokens.shift(), state.unshift(n)\n        }\n        if(token.data === ';') {\n          return tokens.shift(), state.shift()\n        }\n      default: return state.unshift(expr(';'))\n    }\n  }\n\n  function parse_decl() {\n    var stmt = state[0]\n\n    return stative(\n      invariant_or_not,\n      storage_or_not,\n      parameter_or_not,\n      precision_or_not,\n      struct_or_type,\n      maybe_name,\n      maybe_lparen,     // lparen means we're a function\n      is_decllist,\n      done\n    )()\n\n    function invariant_or_not() {\n      if(token.data === 'invariant') {\n        if(stmt.flags & DECL_ALLOW_INVARIANT) {\n          state.unshift(keyword())\n          return Advance\n        } else {\n          return unexpected('`invariant` is not allowed here') \n        }\n      } else {\n        state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))\n        return Advance\n      }\n    }\n\n    function storage_or_not() {\n      if(is_storage(token)) {\n        if(stmt.flags & DECL_ALLOW_STORAGE) {\n          state.unshift(keyword()) \n          return Advance\n        } else {\n          return unexpected('storage is not allowed here') \n        }\n      } else {\n        state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))\n        return Advance\n      }\n    }\n\n    function parameter_or_not() {\n      if(is_parameter(token)) {\n        if(!(stmt.flags & DECL_NO_INOUT)) {\n          state.unshift(keyword()) \n          return Advance\n        } else {\n          return unexpected('parameter is not allowed here') \n        }\n      } else {\n        state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))\n        return Advance\n      }\n    }\n\n    function precision_or_not() {\n      if(is_precision(token)) {\n        state.unshift(keyword())\n        return Advance\n      } else {\n        state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))\n        return Advance\n      }\n    }\n\n    function struct_or_type() {\n      if(token.data === 'struct') {\n        if(!(stmt.flags & DECL_ALLOW_STRUCT)) {\n          return unexpected('cannot nest structs')\n        }\n        state.unshift(struct())\n        return Advance\n      }\n\n      if(token.type === 'keyword') {\n        state.unshift(keyword())\n        return Advance\n      }\n\n      var lookup = state.scope.find(token.data)\n\n      if(lookup) {\n        state.fake(Object.create(lookup))\n        tokens.shift()\n        return Advance  \n      }\n      return unexpected('expected user defined type, struct or keyword, got '+token.data)\n    }\n\n    function maybe_name() {\n      if(token.data === ',' && !(stmt.flags & DECL_ALLOW_COMMA)) {\n        return state.shift()\n      }\n\n      if(token.data === '[') {\n        // oh lord.\n        state.unshift(quantifier())\n        return\n      }\n\n      if(token.data === ')') return state.shift()\n\n      if(token.data === ';') {\n        return stmt.stage + 3\n      }\n\n      if(token.type !== 'ident') {\n        return unexpected('expected identifier, got '+token.data)\n      }\n\n      stmt.collected_name = tokens.shift()\n      return Advance      \n    }\n\n    function maybe_lparen() {\n      if(token.data === '(') {\n        tokens.unshift(stmt.collected_name)\n        delete stmt.collected_name\n        state.unshift(fn())\n        return stmt.stage + 2 \n      }\n      return Advance\n    }\n\n    function is_decllist() {\n      tokens.unshift(stmt.collected_name)\n      delete stmt.collected_name\n      state.unshift(decllist())\n      return Advance\n    }\n\n    function done() {\n      return state.shift()\n    }\n  }\n  \n  function parse_decllist() {\n    // grab ident\n\n    if(token.type === 'ident') {\n      var name = token.data\n      state.unshift(ident())\n      state.scope.define(name)\n      return\n    }\n\n    if(token.type === 'operator') {\n\n      if(token.data === ',') {\n        // multi-decl!\n        if(!(state[1].flags & DECL_ALLOW_COMMA)) {\n          return state.shift()\n        }\n\n        return tokens.shift()\n      } else if(token.data === '=') {\n        if(!(state[1].flags & DECL_ALLOW_ASSIGN)) return unexpected('`=` is not allowed here.')\n\n        tokens.shift()\n\n        state.unshift(expr(',', ';'))\n        return\n      } else if(token.data === '[') {\n        state.unshift(quantifier())\n        return\n      }\n    }\n    return state.shift()\n  }\n\n  function parse_keyword_or_ident() {\n    if(token.type === 'keyword') {\n      state[0].type = 'keyword'\n      state[0].mode = KEYWORD\n      return\n    }\n\n    if(token.type === 'ident') {\n      state[0].type = 'ident'\n      state[0].mode = IDENT\n      return\n    }\n\n    return unexpected('expected keyword or user-defined name, got '+token.data)\n  }\n\n  function parse_keyword() {\n    if(token.type !== 'keyword') {\n      return unexpected('expected keyword, got '+token.data)\n    }\n\n    return state.shift(), tokens.shift()\n  }\n\n  function parse_ident() {\n    if(token.type !== 'ident') {\n      return unexpected('expected user-defined name, got '+token.data)\n    }\n\n    state[0].data = token.data\n    return state.shift(), tokens.shift()\n  }\n\n\n  function parse_expr() {\n    var expecting = state[0].expecting\n\n    state[0].tokens = state[0].tokens || []\n\n    if(state[0].parenlevel === undefined) {\n      state[0].parenlevel = 0\n      state[0].bracelevel = 0\n    }\n    if(state[0].parenlevel < 1 && expecting.indexOf(token.data) > -1) {\n      return parseexpr(state[0].tokens)\n    }\n    if(token.data === '(') {\n      ++state[0].parenlevel\n    } else if(token.data === ')') {\n      --state[0].parenlevel\n    }\n\n    switch(token.data) {\n      case '{': ++state[0].bracelevel; break\n      case '}': --state[0].bracelevel; break\n      case '(': ++state[0].parenlevel; break\n      case ')': --state[0].parenlevel; break\n    }\n\n    if(state[0].parenlevel < 0) return unexpected('unexpected `)`')\n    if(state[0].bracelevel < 0) return unexpected('unexpected `}`')\n\n    state[0].tokens.push(tokens.shift())\n    return\n\n    function parseexpr(tokens) {\n      return full_parse_expr(state, tokens), state.shift()\n    }\n  }\n\n  // node types ---------------\n\n  function n(type) {\n    // this is a function factory that suffices for most kinds of expressions and statements\n    return function() {\n      return mknode(type, token)\n    }\n  }\n\n  function adhoc() {\n    return mknode(token_map[token.type], token, node)\n  }\n\n  function decl(flags) {\n    var _ = mknode(DECL, token, node)\n    _.flags = flags\n\n    return _\n  }\n\n  function struct(allow_assign, allow_comma) {\n    var _ = mknode(STRUCT, token, node)\n    _.allow_assign = allow_assign === undefined ? true : allow_assign\n    _.allow_comma = allow_comma === undefined ? true : allow_comma\n    return _\n  }\n\n  function expr() {\n    var n = mknode(EXPR, token, node)\n\n    n.expecting = [].slice.call(arguments)\n    return n\n  }\n  \n  function keyword(default_value) {\n    var t = token\n    if(default_value) {\n      t = {'type': '(implied)', data: '(default)', position: t.position} \n    }\n    return mknode(KEYWORD, t, node)\n  }\n\n  // utils ----------------------------\n\n  function unexpected(str) {\n    errored = true\n    stream.emit('error', new Error(\n      (str || 'unexpected '+state) +\n      ' at line '+state[0].token.line\n    ))\n  }\n\n  function assert(type, data) {\n    return 1,\n      assert_null_string_or_array(type, token.type) && \n      assert_null_string_or_array(data, token.data)\n  }\n\n  function assert_null_string_or_array(x, y) {\n    switch(typeof x) {\n      case 'string': if(y !== x) {\n        unexpected('expected `'+x+'`, got '+y+'\\n'+token.data);\n      } return !errored\n\n      case 'object': if(x && x.indexOf(y) === -1) {\n        unexpected('expected one of `'+x.join('`, `')+'`, got '+y);\n      } return !errored\n    }\n    return true\n  }\n\n  // stative ----------------------------\n\n  function stative() {\n    var steps = [].slice.call(arguments)\n      , step\n      , result\n\n    return function() {\n      var current = state[0]\n\n      current.stage || (current.stage = 0)\n\n      step = steps[current.stage]\n      if(!step) return unexpected('parser in undefined state!')\n\n      result = step()\n\n      if(result === Advance) return ++current.stage\n      if(result === undefined) return\n      current.stage = result\n    } \n  }\n\n  function advance(op, t) {\n    t = t || 'operator'\n    return function() {\n      if(!assert(t, op)) return\n\n      var last = tokens.shift()\n        , children = state[0].children\n        , last_node = children[children.length - 1]\n\n      if(last_node && last_node.token && last.preceding) {\n        last_node.token.succeeding = last_node.token.succeeding || []\n        last_node.token.succeeding = last_node.token.succeeding.concat(last.preceding)\n      }\n      return Advance\n    }\n  }\n\n  function advance_expr(until) {\n    return function() { return state.unshift(expr(until)), Advance }\n  }\n\n  function advance_ident(declare) {\n    return declare ? function() {\n      var name = token.data\n      return assert('ident') && (state.unshift(ident()), state.scope.define(name), Advance)\n    } :  function() {\n      if(!assert('ident')) return\n\n      var s = Object.create(state.scope.find(token.data))\n      s.token = token\n\n      return (tokens.shift(), Advance)\n    }\n  }\n\n  function advance_stmtlist() {\n    return function() {\n      var n = stmtlist()\n      n.expecting = '}'\n      return state.unshift(n), Advance\n    }\n  }\n\n  function maybe_stmtlist(skip) {\n    return function() {\n      var current = state[0].stage\n      if(token.data !== '{') { return state.unshift(stmt()), current + skip }\n      return tokens.shift(), Advance\n    }\n  }\n\n  function popstmt() {\n    return function() { return state.shift(), state.shift() }\n  }\n\n\n  function setup_stative_parsers() {\n\n    // could also be\n    // struct { } decllist\n    parse_struct =\n        stative(\n          advance('struct', 'keyword')\n        , function() {\n            if(token.data === '{') {\n              state.fake(mknode(IDENT, {data:'', position: token.position, type:'ident'}))\n              return Advance\n            }\n\n            return advance_ident(true)()\n          }\n        , function() { state.scope.enter(); return Advance }\n        , advance('{')\n        , function() {\n            if(token.data === '}') {\n              state.scope.exit()\n              tokens.shift()\n              return state.shift()\n            }\n            if(token.data === ';') { tokens.shift(); return }\n            state.unshift(decl(DECL_STRUCT))\n          }\n        )\n\n    parse_precision =\n        stative(\n          function() { return tokens.shift(), Advance }\n        , function() { \n            return assert(\n            'keyword', ['lowp', 'mediump', 'highp']\n            ) && (state.unshift(keyword()), Advance) \n          }\n        , function() { return (state.unshift(keyword()), Advance) }\n        , function() { return state.shift() } \n        )\n\n    parse_quantifier =\n        stative(\n          advance('[')\n        , advance_expr(']')\n        , advance(']')\n        , function() { return state.shift() }\n        )\n\n    parse_forloop = \n        stative(\n          advance('for', 'keyword')\n        , advance('(')\n        , function() {\n            var lookup\n            if(token.type === 'ident') {\n              if(!(lookup = state.scope.find(token.data))) {\n                lookup = state.create_node()\n              }\n             \n              if(lookup.parent.type === 'struct') {\n                return state.unshift(decl(DECL_STATEMENT)), Advance\n              }\n            } else if(token.type === 'builtin' || token.type === 'keyword') {\n              return state.unshift(decl(DECL_STATEMENT)), Advance\n            }\n            return advance_expr(';')()\n          }\n        , advance(';')\n        , advance_expr(';')\n        , advance(';')\n        , advance_expr(')')\n        , advance(')')\n        , maybe_stmtlist(3)\n        , advance_stmtlist()\n        , advance('}')\n        , popstmt()\n        )\n\n    parse_if = \n        stative(\n          advance('if', 'keyword')\n        , advance('(')\n        , advance_expr(')')\n        , advance(')')\n        , maybe_stmtlist(3)\n        , advance_stmtlist()\n        , advance('}')\n        , function() {\n            if(token.data === 'else') {\n              return tokens.shift(), state.unshift(stmt()), Advance\n            }\n            return popstmt()()\n          }\n        , popstmt()\n        )\n\n    parse_return =\n        stative(\n          advance('return', 'keyword')\n        , function() {\n            if(token.data === ';') return Advance\n            return state.unshift(expr(';')), Advance\n          }\n        , function() { tokens.shift(), popstmt()() } \n        )\n\n    parse_whileloop =\n        stative(\n          advance('while', 'keyword')\n        , advance('(')\n        , advance_expr(')')\n        , advance(')')\n        , maybe_stmtlist(3)\n        , advance_stmtlist()\n        , advance('}')\n        , popstmt()\n        )\n\n    parse_dowhileloop = \n      stative(\n        advance('do', 'keyword')\n      , maybe_stmtlist(3)\n      , advance_stmtlist()\n      , advance('}')\n      , advance('while', 'keyword')\n      , advance('(')\n      , advance_expr(')')\n      , advance(')')\n      , popstmt()\n      )\n\n    parse_function =\n      stative(\n        function() {\n          for(var i = 1, len = state.length; i < len; ++i) if(state[i].mode === FUNCTION) {\n            return unexpected('function definition is not allowed within another function')\n          }\n\n          return Advance\n        }\n      , function() {\n          if(!assert(\"ident\")) return\n\n          var name = token.data\n            , lookup = state.scope.find(name)\n\n          state.unshift(ident())\n          state.scope.define(name)\n\n          state.scope.enter(lookup ? lookup.scope : null)\n          return Advance\n        }\n      , advance('(')\n      , function() { return state.unshift(fnargs()), Advance }\n      , advance(')')\n      , function() { \n          // forward decl\n          if(token.data === ';') {\n            return state.scope.exit(), state.shift(), state.shift()\n          }\n          return Advance\n        }\n      , advance('{')\n      , advance_stmtlist()\n      , advance('}')\n      , function() { state.scope.exit(); return Advance } \n      , function() { return state.shift(), state.shift(), state.shift() }\n      )\n\n    parse_function_args =\n      stative(\n        function() {\n          if(token.data === 'void') { state.fake(keyword()); tokens.shift(); return Advance }\n          if(token.data === ')') { state.shift(); return }\n          if(token.data === 'struct') {\n            state.unshift(struct(NO_ASSIGN_ALLOWED, NO_COMMA_ALLOWED))\n            return Advance\n          }\n          state.unshift(decl(DECL_FUNCTION))\n          return Advance\n        }\n      , function() {\n          if(token.data === ',') { tokens.shift(); return 0 }\n          if(token.data === ')') { state.shift(); return }\n          unexpected('expected one of `,` or `)`, got '+token.data)\n        }\n      )\n  }\n}\n\nfunction mknode(mode, sourcetoken) {\n  return {\n      mode: mode\n    , token: sourcetoken\n    , children: []\n    , type: stmt_type[mode]\n    , id: (Math.random() * 0xFFFFFFFF).toString(16)\n  }\n}\n\nfunction is_storage(token) {\n  return token.data === 'const' ||\n         token.data === 'attribute' ||\n         token.data === 'uniform' ||\n         token.data === 'varying'\n}\n\nfunction is_parameter(token) {\n  return token.data === 'in' ||\n         token.data === 'inout' ||\n         token.data === 'out'\n}\n\nfunction is_precision(token) {\n  return token.data === 'highp' ||\n         token.data === 'mediump' ||\n         token.data === 'lowp'\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-parser/lib/index.js?");

/***/ }),

/***/ "./node_modules/glsl-parser/lib/scope.js":
/*!***********************************************!*\
  !*** ./node_modules/glsl-parser/lib/scope.js ***!
  \***********************************************/
/***/ ((module) => {

eval("module.exports = scope\n\nfunction scope(state) {\n  if(this.constructor !== scope)\n    return new scope(state)\n\n  this.state = state\n  this.scopes = []\n  this.current = null\n}\n\nvar cons = scope\n  , proto = cons.prototype\n\nproto.enter = function(s) {\n  this.scopes.push(\n    this.current = this.state[0].scope = s || {}\n  )\n}\n\nproto.exit = function() {\n  this.scopes.pop()\n  this.current = this.scopes[this.scopes.length - 1]\n}\n\nproto.define = function(str) {\n  this.current[str] = this.state[0]\n}\n\nproto.find = function(name, fail) {\n  for(var i = this.scopes.length - 1; i > -1; --i) {\n    if(this.scopes[i].hasOwnProperty(name)) {\n      return this.scopes[i][name]\n    }\n  }\n\n  return null\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-parser/lib/scope.js?");

/***/ }),

/***/ "./node_modules/glsl-parser/node_modules/through/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/glsl-parser/node_modules/through/index.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\nvar Stream = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\")\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\n\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end) {\n  write = write || function (data) { this.emit('data', data) }\n  end = end || function () { this.emit('end') }\n\n  var ended = false, destroyed = false\n  var stream = new Stream(), buffer = []\n  stream.buffer = buffer\n  stream.readable = stream.writable = true\n  stream.paused = false\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = function (data) {\n    buffer.push(data)\n    drain()\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    stream.emit('pause')\n  }\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n  }\n  return stream\n}\n\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-parser/node_modules/through/index.js?");

/***/ }),

/***/ "./node_modules/glsl-tokenizer/index.js":
/*!**********************************************!*\
  !*** ./node_modules/glsl-tokenizer/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = tokenize\n\nvar through = __webpack_require__(/*! through */ \"./node_modules/through/index.js\")\n\nvar literals = __webpack_require__(/*! ./lib/literals */ \"./node_modules/glsl-tokenizer/lib/literals.js\")\n  , operators = __webpack_require__(/*! ./lib/operators */ \"./node_modules/glsl-tokenizer/lib/operators.js\")\n  , builtins = __webpack_require__(/*! ./lib/builtins */ \"./node_modules/glsl-tokenizer/lib/builtins.js\")\n\nvar NORMAL = 999          // <-- never emitted\n  , TOKEN = 9999          // <-- never emitted \n  , BLOCK_COMMENT = 0 \n  , LINE_COMMENT = 1\n  , PREPROCESSOR = 2\n  , OPERATOR = 3\n  , INTEGER = 4\n  , FLOAT = 5\n  , IDENT = 6\n  , BUILTIN = 7\n  , KEYWORD = 8\n  , WHITESPACE = 9\n  , EOF = 10 \n  , HEX = 11\n\nvar map = [\n    'block-comment'\n  , 'line-comment'\n  , 'preprocessor'\n  , 'operator'\n  , 'integer'\n  , 'float'\n  , 'ident'\n  , 'builtin'\n  , 'keyword'\n  , 'whitespace'\n  , 'eof'\n  , 'integer'\n]\n\nfunction tokenize() {\n  var stream = through(write, end)\n\n  var i = 0\n    , total = 0\n    , mode = NORMAL \n    , c\n    , last\n    , content = []\n    , token_idx = 0\n    , token_offs = 0\n    , line = 1\n    , start = 0\n    , isnum = false\n    , isoperator = false\n    , input = ''\n    , len\n\n  return stream\n\n  function token(data) {\n    if(data.length) {\n      stream.queue({\n        type: map[mode]\n      , data: data\n      , position: start\n      , line: line\n      })\n    }\n  }\n\n  function write(chunk) {\n    i = 0\n    input += chunk.toString()\n    len = input.length\n\n    while(c = input[i], i < len) switch(mode) {\n      case BLOCK_COMMENT: i = block_comment(); break\n      case LINE_COMMENT: i = line_comment(); break\n      case PREPROCESSOR: i = preprocessor(); break \n      case OPERATOR: i = operator(); break\n      case INTEGER: i = integer(); break\n      case HEX: i = hex(); break\n      case FLOAT: i = decimal(); break\n      case TOKEN: i = readtoken(); break\n      case WHITESPACE: i = whitespace(); break\n      case NORMAL: i = normal(); break\n    }\n\n    total += i\n    input = input.slice(i)\n  } \n\n  function end(chunk) {\n    if(content.length) {\n      token(content.join(''))\n    }\n\n    mode = EOF\n    token('(eof)')\n\n    stream.queue(null)\n  }\n\n  function normal() {\n    content = content.length ? [] : content\n\n    if(last === '/' && c === '*') {\n      start = total + i - 1\n      mode = BLOCK_COMMENT\n      last = c\n      return i + 1\n    }\n\n    if(last === '/' && c === '/') {\n      start = total + i - 1\n      mode = LINE_COMMENT\n      last = c\n      return i + 1\n    }\n\n    if(c === '#') {\n      mode = PREPROCESSOR\n      start = total + i\n      return i\n    }\n\n    if(/\\s/.test(c)) {\n      mode = WHITESPACE\n      start = total + i\n      return i\n    }\n\n    isnum = /\\d/.test(c)\n    isoperator = /[^\\w_]/.test(c)\n\n    start = total + i\n    mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN\n    return i\n  }\n\n  function whitespace() {\n    if(c === '\\n') ++line\n\n    if(/[^\\s]/g.test(c)) {\n      token(content.join(''))\n      mode = NORMAL\n      return i\n    }\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function preprocessor() {\n    if(c === '\\n') ++line\n\n    if(c === '\\n' && last !== '\\\\') {\n      token(content.join(''))\n      mode = NORMAL\n      return i\n    }\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function line_comment() {\n    return preprocessor()\n  }\n\n  function block_comment() {\n    if(c === '/' && last === '*') {\n      content.push(c)\n      token(content.join(''))\n      mode = NORMAL\n      return i + 1\n    }\n\n    if(c === '\\n') ++line\n\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function operator() {\n    if(last === '.' && /\\d/.test(c)) {\n      mode = FLOAT\n      return i\n    }\n\n    if(last === '/' && c === '*') {\n      mode = BLOCK_COMMENT\n      return i\n    }\n\n    if(last === '/' && c === '/') {\n      mode = LINE_COMMENT\n      return i\n    }\n\n    if(c === '.' && content.length) {\n      while(determine_operator(content));\n      \n      mode = FLOAT\n      return i\n    }\n\n    if(c === ';') {\n      if(content.length) while(determine_operator(content));\n      token(c)\n      mode = NORMAL\n      return i + 1\n    }\n\n    var is_composite_operator = content.length === 2 && c !== '='\n    if(/[\\w_\\d\\s]/.test(c) || is_composite_operator) {\n      while(determine_operator(content));\n      mode = NORMAL\n      return i\n    }\n\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function determine_operator(buf) {\n    var j = 0\n      , idx\n\n    do {\n      idx = operators.indexOf(buf.slice(0, buf.length + j).join(''))\n      if(idx === -1) { \n        j -= 1\n        continue\n      }\n      \n      token(operators[idx])\n\n      start += operators[idx].length\n      content = content.slice(operators[idx].length)\n      return content.length\n    } while(1)\n  }\n\n  function hex() {\n    if(/[^a-fA-F0-9]/.test(c)) {\n      token(content.join(''))\n      mode = NORMAL\n      return i\n    }\n\n    content.push(c)\n    last = c\n    return i + 1    \n  }\n\n  function integer() {\n    if(c === '.') {\n      content.push(c)\n      mode = FLOAT\n      last = c\n      return i + 1\n    }\n\n    if(/[eE]/.test(c)) {\n      content.push(c)\n      mode = FLOAT\n      last = c\n      return i + 1\n    }\n\n    if(c === 'x' && content.length === 1 && content[0] === '0') {\n      mode = HEX\n      content.push(c)\n      last = c\n      return i + 1\n    }\n\n    if(/[^\\d]/.test(c)) {\n      token(content.join(''))\n      mode = NORMAL\n      return i\n    }\n\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function decimal() {\n    if(c === 'f') {\n      content.push(c)\n      last = c\n      i += 1\n    }\n\n    if(/[eE]/.test(c)) {\n      content.push(c)\n      last = c\n      return i + 1\n    }\n\n    if(/[^\\d]/.test(c)) {\n      token(content.join(''))\n      mode = NORMAL\n      return i\n    }\n    content.push(c)\n    last = c\n    return i + 1\n  }\n\n  function readtoken() {\n    if(/[^\\d\\w_]/.test(c)) {\n      var contentstr = content.join('')\n      if(literals.indexOf(contentstr) > -1) {\n        mode = KEYWORD\n      } else if(builtins.indexOf(contentstr) > -1) {\n        mode = BUILTIN\n      } else {\n        mode = IDENT\n      }\n      token(content.join(''))\n      mode = NORMAL\n      return i\n    }\n    content.push(c)\n    last = c\n    return i + 1\n  }\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-tokenizer/index.js?");

/***/ }),

/***/ "./node_modules/glsl-tokenizer/lib/builtins.js":
/*!*****************************************************!*\
  !*** ./node_modules/glsl-tokenizer/lib/builtins.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("module.exports = [\n    'gl_Position'\n  , 'gl_PointSize'\n  , 'gl_ClipVertex'\n  , 'gl_FragCoord'\n  , 'gl_FrontFacing'\n  , 'gl_FragColor'\n  , 'gl_FragData'\n  , 'gl_FragDepth'\n  , 'gl_Color'\n  , 'gl_SecondaryColor'\n  , 'gl_Normal'\n  , 'gl_Vertex'\n  , 'gl_MultiTexCoord0'\n  , 'gl_MultiTexCoord1'\n  , 'gl_MultiTexCoord2'\n  , 'gl_MultiTexCoord3'\n  , 'gl_MultiTexCoord4'\n  , 'gl_MultiTexCoord5'\n  , 'gl_MultiTexCoord6'\n  , 'gl_MultiTexCoord7'\n  , 'gl_FogCoord'\n  , 'gl_MaxLights'\n  , 'gl_MaxClipPlanes'\n  , 'gl_MaxTextureUnits'\n  , 'gl_MaxTextureCoords'\n  , 'gl_MaxVertexAttribs'\n  , 'gl_MaxVertexUniformComponents'\n  , 'gl_MaxVaryingFloats'\n  , 'gl_MaxVertexTextureImageUnits'\n  , 'gl_MaxCombinedTextureImageUnits'\n  , 'gl_MaxTextureImageUnits'\n  , 'gl_MaxFragmentUniformComponents'\n  , 'gl_MaxDrawBuffers'\n  , 'gl_ModelViewMatrix'\n  , 'gl_ProjectionMatrix'\n  , 'gl_ModelViewProjectionMatrix'\n  , 'gl_TextureMatrix'\n  , 'gl_NormalMatrix'\n  , 'gl_ModelViewMatrixInverse'\n  , 'gl_ProjectionMatrixInverse'\n  , 'gl_ModelViewProjectionMatrixInverse'\n  , 'gl_TextureMatrixInverse'\n  , 'gl_ModelViewMatrixTranspose'\n  , 'gl_ProjectionMatrixTranspose'\n  , 'gl_ModelViewProjectionMatrixTranspose'\n  , 'gl_TextureMatrixTranspose'\n  , 'gl_ModelViewMatrixInverseTranspose'\n  , 'gl_ProjectionMatrixInverseTranspose'\n  , 'gl_ModelViewProjectionMatrixInverseTranspose'\n  , 'gl_TextureMatrixInverseTranspose'\n  , 'gl_NormalScale'\n  , 'gl_DepthRangeParameters'\n  , 'gl_DepthRange'\n  , 'gl_ClipPlane'\n  , 'gl_PointParameters'\n  , 'gl_Point'\n  , 'gl_MaterialParameters'\n  , 'gl_FrontMaterial'\n  , 'gl_BackMaterial'\n  , 'gl_LightSourceParameters'\n  , 'gl_LightSource'\n  , 'gl_LightModelParameters'\n  , 'gl_LightModel'\n  , 'gl_LightModelProducts'\n  , 'gl_FrontLightModelProduct'\n  , 'gl_BackLightModelProduct'\n  , 'gl_LightProducts'\n  , 'gl_FrontLightProduct'\n  , 'gl_BackLightProduct'\n  , 'gl_FogParameters'\n  , 'gl_Fog'\n  , 'gl_TextureEnvColor'\n  , 'gl_EyePlaneS'\n  , 'gl_EyePlaneT'\n  , 'gl_EyePlaneR'\n  , 'gl_EyePlaneQ'\n  , 'gl_ObjectPlaneS'\n  , 'gl_ObjectPlaneT'\n  , 'gl_ObjectPlaneR'\n  , 'gl_ObjectPlaneQ'\n  , 'gl_FrontColor'\n  , 'gl_BackColor'\n  , 'gl_FrontSecondaryColor'\n  , 'gl_BackSecondaryColor'\n  , 'gl_TexCoord'\n  , 'gl_FogFragCoord'\n  , 'gl_Color'\n  , 'gl_SecondaryColor'\n  , 'gl_TexCoord'\n  , 'gl_FogFragCoord'\n  , 'gl_PointCoord'\n  , 'radians'\n  , 'degrees'\n  , 'sin'\n  , 'cos'\n  , 'tan'\n  , 'asin'\n  , 'acos'\n  , 'atan'\n  , 'pow'\n  , 'exp'\n  , 'log'\n  , 'exp2'\n  , 'log2'\n  , 'sqrt'\n  , 'inversesqrt'\n  , 'abs'\n  , 'sign'\n  , 'floor'\n  , 'ceil'\n  , 'fract'\n  , 'mod'\n  , 'min'\n  , 'max'\n  , 'clamp'\n  , 'mix'\n  , 'step'\n  , 'smoothstep'\n  , 'length'\n  , 'distance'\n  , 'dot'\n  , 'cross'\n  , 'normalize'\n  , 'faceforward'\n  , 'reflect'\n  , 'refract'\n  , 'matrixCompMult'\n  , 'lessThan'\n  , 'lessThanEqual'\n  , 'greaterThan'\n  , 'greaterThanEqual'\n  , 'equal'\n  , 'notEqual'\n  , 'any'\n  , 'all'\n  , 'not'\n  , 'texture2D'\n  , 'texture2DProj'\n  , 'texture2DLod'\n  , 'texture2DProjLod'\n  , 'textureCube'\n  , 'textureCubeLod'\n]\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-tokenizer/lib/builtins.js?");

/***/ }),

/***/ "./node_modules/glsl-tokenizer/lib/literals.js":
/*!*****************************************************!*\
  !*** ./node_modules/glsl-tokenizer/lib/literals.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("module.exports = [\n  // current\n    'precision'\n  , 'highp'\n  , 'mediump'\n  , 'lowp'\n  , 'attribute'\n  , 'const'\n  , 'uniform'\n  , 'varying'\n  , 'break'\n  , 'continue'\n  , 'do'\n  , 'for'\n  , 'while'\n  , 'if'\n  , 'else'\n  , 'in'\n  , 'out'\n  , 'inout'\n  , 'float'\n  , 'int'\n  , 'void'\n  , 'bool'\n  , 'true'\n  , 'false'\n  , 'discard'\n  , 'return'\n  , 'mat2'\n  , 'mat3'\n  , 'mat4'\n  , 'vec2'\n  , 'vec3'\n  , 'vec4'\n  , 'ivec2'\n  , 'ivec3'\n  , 'ivec4'\n  , 'bvec2'\n  , 'bvec3'\n  , 'bvec4'\n  , 'sampler1D'\n  , 'sampler2D'\n  , 'sampler3D'\n  , 'samplerCube'\n  , 'sampler1DShadow'\n  , 'sampler2DShadow'\n  , 'struct'\n\n  // future\n  , 'asm'\n  , 'class'\n  , 'union'\n  , 'enum'\n  , 'typedef'\n  , 'template'\n  , 'this'\n  , 'packed'\n  , 'goto'\n  , 'switch'\n  , 'default'\n  , 'inline'\n  , 'noinline'\n  , 'volatile'\n  , 'public'\n  , 'static'\n  , 'extern'\n  , 'external'\n  , 'interface'\n  , 'long'\n  , 'short'\n  , 'double'\n  , 'half'\n  , 'fixed'\n  , 'unsigned'\n  , 'input'\n  , 'output'\n  , 'hvec2'\n  , 'hvec3'\n  , 'hvec4'\n  , 'dvec2'\n  , 'dvec3'\n  , 'dvec4'\n  , 'fvec2'\n  , 'fvec3'\n  , 'fvec4'\n  , 'sampler2DRect'\n  , 'sampler3DRect'\n  , 'sampler2DRectShadow'\n  , 'sizeof'\n  , 'cast'\n  , 'namespace'\n  , 'using'\n]\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-tokenizer/lib/literals.js?");

/***/ }),

/***/ "./node_modules/glsl-tokenizer/lib/operators.js":
/*!******************************************************!*\
  !*** ./node_modules/glsl-tokenizer/lib/operators.js ***!
  \******************************************************/
/***/ ((module) => {

eval("module.exports = [\n    '<<='\n  , '>>='\n  , '++'\n  , '--'\n  , '<<'\n  , '>>'\n  , '<='\n  , '>='\n  , '=='\n  , '!='\n  , '&&'\n  , '||'\n  , '+='\n  , '-='\n  , '*='\n  , '/='\n  , '%='\n  , '&='\n  , '^='\n  , '|='\n  , '('\n  , ')'\n  , '['\n  , ']'\n  , '.'\n  , '!'\n  , '~'\n  , '*'\n  , '/'\n  , '%'\n  , '+'\n  , '-'\n  , '<'\n  , '>'\n  , '&'\n  , '^'\n  , '|'\n  , '?'\n  , ':'\n  , '='\n  , ','\n  , ';'\n  , '{'\n  , '}'\n]\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/glsl-tokenizer/lib/operators.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/***/ ((module) => {

eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/process/browser.js?");

/***/ }),

/***/ "./src/assets/objects/textured-cube.obj":
/*!**********************************************!*\
  !*** ./src/assets/objects/textured-cube.obj ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"# Blender v2.79 (sub 0) OBJ File: ''\\n# www.blender.org\\nmtllib textured-cube.mtl\\no Cube_Cube.001\\nv -1.000000 -1.000000 1.000000\\nv -1.000000 1.000000 1.000000\\nv -1.000000 -1.000000 -1.000000\\nv -1.000000 1.000000 -1.000000\\nv 1.000000 -1.000000 1.000000\\nv 1.000000 1.000000 1.000000\\nv 1.000000 -1.000000 -1.000000\\nv 1.000000 1.000000 -1.000000\\nvt 0.625000 0.000000\\nvt 0.375000 0.250000\\nvt 0.375000 0.000000\\nvt 0.625000 0.250000\\nvt 0.375000 0.500000\\nvt 0.625000 0.500000\\nvt 0.375000 0.750000\\nvt 0.625000 0.750000\\nvt 0.375000 1.000000\\nvt 0.125000 0.750000\\nvt 0.125000 0.500000\\nvt 0.875000 0.500000\\nvt 0.625000 1.000000\\nvt 0.875000 0.750000\\nvn -1.0000 0.0000 0.0000\\nvn 0.0000 0.0000 -1.0000\\nvn 1.0000 0.0000 0.0000\\nvn 0.0000 0.0000 1.0000\\nvn 0.0000 -1.0000 0.0000\\nvn 0.0000 1.0000 0.0000\\nusemtl None\\ns off\\nf 2/1/1 3/2/1 1/3/1\\nf 4/4/2 7/5/2 3/2/2\\nf 8/6/3 5/7/3 7/5/3\\nf 6/8/4 1/9/4 5/7/4\\nf 7/5/5 1/10/5 3/11/5\\nf 4/12/6 6/8/6 8/6/6\\nf 2/1/1 4/4/1 3/2/1\\nf 4/4/2 8/6/2 7/5/2\\nf 8/6/3 6/8/3 5/7/3\\nf 6/8/4 2/13/4 1/9/4\\nf 7/5/5 5/7/5 1/10/5\\nf 4/12/6 2/14/6 6/8/6\\n\");\n\n//# sourceURL=webpack://webgl-month/./src/assets/objects/textured-cube.obj?");

/***/ }),

/***/ "./src/shaders/3d-textured.f.glsl":
/*!****************************************!*\
  !*** ./src/shaders/3d-textured.f.glsl ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"precision mediump float;\\nuniform sampler2D texture;\\n\\nvarying vec2 vTexCoord;\\n\\nvoid main() {\\n  gl_FragColor = texture2D(texture, vTexCoord * vec2(1, -1) + vec2(0, 1));\\n}\\n\");\n\n//# sourceURL=webpack://webgl-month/./src/shaders/3d-textured.f.glsl?");

/***/ }),

/***/ "./src/shaders/3d-textured.v.glsl":
/*!****************************************!*\
  !*** ./src/shaders/3d-textured.v.glsl ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"attribute vec3 position;\\nattribute vec2 texCoord;\\nattribute mat4 modelMatrix;\\n\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nvarying vec2 vTexCoord;\\n\\nvoid main() {\\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\\n\\n  vTexCoord = texCoord;\\n}\\n\");\n\n//# sourceURL=webpack://webgl-month/./src/shaders/3d-textured.v.glsl?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = false;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // In streams that never have any data, and do push(null) right away,\n  // the consumer can miss the 'end' event if they do some I/O before\n  // consuming the stream.  So, we don't emit('end') until some reading\n  // happens.\n  this.calledRead = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/index.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (typeof chunk === 'string' && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null || chunk === undefined) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      // update the buffer info.\n      state.length += state.objectMode ? 1 : chunk.length;\n      if (addToFront) {\n        state.buffer.unshift(chunk);\n      } else {\n        state.reading = false;\n        state.buffer.push(chunk);\n      }\n\n      if (state.needReadable)\n        emitReadable(stream);\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/index.js\").StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  var state = this._readableState;\n  state.calledRead = true;\n  var nOrig = n;\n  var ret;\n\n  if (typeof n !== 'number' || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    ret = null;\n\n    // In cases where the decoder did not receive enough data\n    // to produce a full chunk, then immediately received an\n    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].\n    // howMuchToRead will see this and coerce the amount to\n    // read to zero (because it's looking at the length of the\n    // first <Buffer > in state.buffer), and we'll end up here.\n    //\n    // This can only happen via state.decoder -- no other venue\n    // exists for pushing a zero-length chunk into state.buffer\n    // and triggering this behavior. In this case, we return our\n    // remaining data and end the stream, if appropriate.\n    if (state.length > 0 && state.decoder) {\n      ret = fromList(n, state);\n      state.length -= ret.length;\n    }\n\n    if (state.length === 0)\n      endReadable(this);\n\n    return ret;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length - n <= state.highWaterMark)\n    doRead = true;\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading)\n    doRead = false;\n\n  if (doRead) {\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read called its callback synchronously, then `reading`\n  // will be false, and we need to re-evaluate how much data we\n  // can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we happened to read() exactly the remaining amount in the\n  // buffer, and the EOF has been seen at this point, then make sure\n  // that we emit 'end' on the very next tick.\n  if (state.ended && !state.endEmitted && state.length === 0)\n    endReadable(this);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // if we've ended and we have some data left, then emit\n  // 'readable' now to make sure it gets picked up.\n  if (state.length > 0)\n    emitReadable(stream);\n  else\n    endReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (state.emittedReadable)\n    return;\n\n  state.emittedReadable = true;\n  if (state.sync)\n    process.nextTick(function() {\n      emitReadable_(stream);\n    });\n  else\n    emitReadable_(stream);\n}\n\nfunction emitReadable_(stream) {\n  stream.emit('readable');\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    if (readable !== src) return;\n    cleanup();\n  }\n\n  function onend() {\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (!dest._writableState || dest._writableState.needDrain)\n      ondrain();\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    // the handler that waits for readable events after all\n    // the data gets sucked out in flow.\n    // This would be easier to follow with a .once() handler\n    // in flow(), but that is too slow.\n    this.on('readable', pipeOnReadable);\n\n    state.flowing = true;\n    process.nextTick(function() {\n      flow(src);\n    });\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var dest = this;\n    var state = src._readableState;\n    state.awaitDrain--;\n    if (state.awaitDrain === 0)\n      flow(src);\n  };\n}\n\nfunction flow(src) {\n  var state = src._readableState;\n  var chunk;\n  state.awaitDrain = 0;\n\n  function write(dest, i, list) {\n    var written = dest.write(chunk);\n    if (false === written) {\n      state.awaitDrain++;\n    }\n  }\n\n  while (state.pipesCount && null !== (chunk = src.read())) {\n\n    if (state.pipesCount === 1)\n      write(state.pipes, 0, null);\n    else\n      forEach(state.pipes, write);\n\n    src.emit('data', chunk);\n\n    // if anyone needs a drain, then we have to wait for that.\n    if (state.awaitDrain > 0)\n      return;\n  }\n\n  // if every destination was unpiped, either before entering this\n  // function, or in the while loop, then stop flowing.\n  //\n  // NB: This is a pretty rare edge case.\n  if (state.pipesCount === 0) {\n    state.flowing = false;\n\n    // if there were data event listeners added, then switch to old mode.\n    if (EE.listenerCount(src, 'data') > 0)\n      emitDataEvents(src);\n    return;\n  }\n\n  // at this point, no one needed a drain, so we just ran out of data\n  // on the next readable event, start it over again.\n  state.ranOut = true;\n}\n\nfunction pipeOnReadable() {\n  if (this._readableState.ranOut) {\n    this._readableState.ranOut = false;\n    flow(this);\n  }\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    this.removeListener('readable', pipeOnReadable);\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data' && !this._readableState.flowing)\n    emitDataEvents(this);\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        this.read(0);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  emitDataEvents(this);\n  this.read(0);\n  this.emit('resume');\n};\n\nReadable.prototype.pause = function() {\n  emitDataEvents(this, true);\n  this.emit('pause');\n};\n\nfunction emitDataEvents(stream, startPaused) {\n  var state = stream._readableState;\n\n  if (state.flowing) {\n    // https://github.com/isaacs/readable-stream/issues/16\n    throw new Error('Cannot switch to old mode now.');\n  }\n\n  var paused = startPaused || false;\n  var readable = false;\n\n  // convert to an old-style stream.\n  stream.readable = true;\n  stream.pipe = Stream.prototype.pipe;\n  stream.on = stream.addListener = Stream.prototype.on;\n\n  stream.on('readable', function() {\n    readable = true;\n\n    var c;\n    while (!paused && (null !== (c = stream.read())))\n      stream.emit('data', c);\n\n    if (c === null) {\n      readable = false;\n      stream._readableState.needReadable = true;\n    }\n  });\n\n  stream.pause = function() {\n    paused = true;\n    this.emit('pause');\n  };\n\n  stream.resume = function() {\n    paused = false;\n    if (readable)\n      process.nextTick(function() {\n        stream.emit('readable');\n      });\n    else\n      this.read(0);\n    this.emit('resume');\n  };\n\n  // now make it start, just in case it hadn't already.\n  stream.emit('readable');\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    //if (state.objectMode && util.isNullOrUndefined(chunk))\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (typeof stream[i] === 'function' &&\n        typeof this[i] === 'undefined') {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted && state.calledRead) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  var ts = this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('finish', function() {\n    if ('function' === typeof this._flush)\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var rs = stream._readableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nvar Stream = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, becuase any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!Buffer.isBuffer(chunk) &&\n      'string' !== typeof chunk &&\n      chunk !== null &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb))\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\n  return ret;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (Buffer.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      cb(er);\n    });\n  else\n    cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished && !state.bufferProcessing && state.buffer.length)\n      clearBuffer(stream, state);\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  cb();\n  if (finished)\n    finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  for (var c = 0; c < state.buffer.length; c++) {\n    var entry = state.buffer[c];\n    var chunk = entry.chunk;\n    var encoding = entry.encoding;\n    var cb = entry.callback;\n    var len = state.objectMode ? 1 : chunk.length;\n\n    doWrite(stream, state, len, chunk, encoding, cb);\n\n    // if we didn't call the onwrite immediately, then\n    // it means that we need to wait until it does.\n    // also, that means that the chunk and cb are currently\n    // being processed, so move the buffer counter past them.\n    if (state.writing) {\n      c++;\n      break;\n    }\n  }\n\n  state.bufferProcessing = false;\n  if (c < state.buffer.length)\n    state.buffer = state.buffer.slice(c);\n  else\n    state.buffer.length = 0;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (typeof chunk !== 'undefined' && chunk !== null)\n    this.write(chunk, encoding);\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    state.finished = true;\n    stream.emit('finish');\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/readable-stream/lib/_stream_transform.js\")\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/readable-stream/transform.js?");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\ninherits(Stream, EE);\nStream.Readable = __webpack_require__(/*! readable-stream/lib/_stream_readable.js */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_readable.js\");\nStream.Writable = __webpack_require__(/*! readable-stream/lib/_stream_writable.js */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_writable.js\");\nStream.Duplex = __webpack_require__(/*! readable-stream/lib/_stream_duplex.js */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js\");\nStream.Transform = __webpack_require__(/*! readable-stream/lib/_stream_transform.js */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_transform.js\");\nStream.PassThrough = __webpack_require__(/*! readable-stream/lib/_stream_passthrough.js */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_passthrough.js\");\nStream.finished = __webpack_require__(/*! readable-stream/lib/internal/streams/end-of-stream.js */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\")\nStream.pipeline = __webpack_require__(/*! readable-stream/lib/internal/streams/pipeline.js */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/pipeline.js\")\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/index.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_readable.js\");\n\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_writable.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_transform.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_readable.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_readable.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = __webpack_require__.g.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = __webpack_require__(/*! util */ \"?19e6\");\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/stream-browserify/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js\");\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/stream-browserify/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = __webpack_require__(/*! ./internal/streams/from */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/from-browser.js\");\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_transform.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_transform.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\nmodule.exports = Transform;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_writable.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_writable.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = __webpack_require__.g.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js\"); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = __webpack_require__(/*! ./end-of-stream */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/async_iterator.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \*********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\"),\n    Buffer = _require.Buffer;\n\nvar _require2 = __webpack_require__(/*! util */ \"?3e83\"),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/buffer_list.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \***********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\nvar ERR_STREAM_PREMATURE_CLOSE = __webpack_require__(/*! ../../../errors */ \"./node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js\").codes.ERR_STREAM_PREMATURE_CLOSE;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/from-browser.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/from-browser.js ***!
  \**********************************************************************************************************/
/***/ ((module) => {

eval("module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/from-browser.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = __webpack_require__(/*! ../../../errors */ \"./node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ \"./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/pipeline.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/state.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/state.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ERR_INVALID_OPT_VALUE = __webpack_require__(/*! ../../../errors */ \"./node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js\").codes.ERR_INVALID_OPT_VALUE;\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/state.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/stream-browser.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/node_modules/string_decoder/lib/string_decoder.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/stream-browserify/node_modules/string_decoder/lib/string_decoder.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack://webgl-month/./node_modules/stream-browserify/node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "./node_modules/string_decoder/index.js":
/*!**********************************************!*\
  !*** ./node_modules/string_decoder/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/string_decoder/index.js?");

/***/ }),

/***/ "./node_modules/through/index.js":
/*!***************************************!*\
  !*** ./node_modules/through/index.js ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\nvar Stream = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\")\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data === null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/through/index.js?");

/***/ }),

/***/ "./src/assets/images/cube-texture.png":
/*!********************************************!*\
  !*** ./src/assets/images/cube-texture.png ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAGAGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDAgNzkuMTYwNDUxLCAyMDE3LzA1LzA2LTAxOjA4OjIxICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTktMDctMjVUMTU6MzI6MzUrMDM6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE5LTA3LTI1VDE1OjM5OjMxKzAzOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE5LTA3LTI1VDE1OjM5OjMxKzAzOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjJjYzUwMDgxLTc0ZjMtNDI5Yy1iZGU3LTY0N2M5YjE1MDJlNCIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmJlZTMxNGY4LWQ3YzQtNzQ0Mi1hNzE1LWM5ZjFiZjM5Y2IxYiIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjBiMTgxMTFmLWVlMjUtNGZkMS05OGU0LWNiYzgxYzMyYjc1NCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MGIxODExMWYtZWUyNS00ZmQxLTk4ZTQtY2JjODFjMzJiNzU0IiBzdEV2dDp3aGVuPSIyMDE5LTA3LTI1VDE1OjMyOjM1KzAzOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MmNjNTAwODEtNzRmMy00MjljLWJkZTctNjQ3YzliMTUwMmU0IiBzdEV2dDp3aGVuPSIyMDE5LTA3LTI1VDE1OjM5OjMxKzAzOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4WzZrYAAHofklEQVR42uz9W7Ns2XXfif3GmCv3PucUqgqFQqFAgIRImiIpUgQlii21pJbULfVDuyPcL3aEH/0J7Ad/CH8eR/jB/dDhkNRqS4pQWzRFUgIvEG9Aoe5AVZ06Z2euOf5+GGPOtXKfwoUiiQhrrwEWq84+uTNXrly5xu1/MUAcccQDjK//4s9+8//6f/wnP3v33beABaPTFIAhOsL47T95H7rADQnMDAA30WLlV3/551msA8LwfGIzIsDceeeddwkMmSMB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\");\n\n//# sourceURL=webpack://webgl-month/./src/assets/images/cube-texture.png?");

/***/ }),

/***/ "./node_modules/utf8-stream/index.js":
/*!*******************************************!*\
  !*** ./node_modules/utf8-stream/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! readable-stream/transform */ \"./node_modules/readable-stream/transform.js\");\n\nmodule.exports = function () {\n    var tr = Transform();\n    var index = 0;\n    var buffer = null;\n    \n    tr._transform = function (chunk, enc, next) {\n        var len = chunk.length;\n        if (len === 0) return next();\n        var i = 0;\n        \n        if (buffer) {\n            var blen = buffer.length;\n            for (; i < len; i++) {\n                buffer[index++] = chunk[i];\n                if (index === blen) {\n                    this.push(buffer);\n                    buffer = null;\n                    i++;\n                    break;\n                }\n            }\n            if (buffer) return next();\n        }\n        \n        for (var j = Math.max(i, len - 5); j < len; j++) {\n            var n = nbytes(chunk[j]);\n            if (n > len - j) {\n                if (j - i > 0) this.push(chunk.slice(i, j));\n                buffer = Buffer(n);\n                for (index = 0; index < len - j; index++) {\n                    buffer[index] = chunk[j + index];\n                }\n                break;\n            }\n        }\n        \n        if (!buffer && i < len) {\n            this.push(i ? chunk.slice(i) : chunk);\n        }\n        next();\n    };\n    \n    tr._flush = function () {\n        if (buffer) this.push(buffer.slice(0, index));\n        this.push(null);\n    };\n    \n    return tr;\n};\n\nfunction nbytes (b) {\n    if (b >= 252) return 6;\n    else if (b >= 248) return 5;\n    else if (b >= 240) return 4;\n    else if (b >= 224) return 3;\n    else if (b >= 192) return 2;\n    else return 1;\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/utf8-stream/index.js?");

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!__webpack_require__.g.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = __webpack_require__.g.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n\n//# sourceURL=webpack://webgl-month/./node_modules/util-deprecate/browser.js?");

/***/ }),

/***/ "./src/3d-textured.js":
/*!****************************!*\
  !*** ./src/3d-textured.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/mat4.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/vec3.js\");\n/* harmony import */ var _shaders_3d_textured_v_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaders/3d-textured.v.glsl */ \"./src/shaders/3d-textured.v.glsl\");\n/* harmony import */ var _shaders_3d_textured_f_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/3d-textured.f.glsl */ \"./src/shaders/3d-textured.f.glsl\");\n/* harmony import */ var _gl_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gl-helpers */ \"./src/gl-helpers.js\");\n/* harmony import */ var _Object3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Object3D */ \"./src/Object3D.js\");\n/* harmony import */ var _GLBuffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GLBuffer */ \"./src/GLBuffer.js\");\n/* harmony import */ var _assets_objects_textured_cube_obj__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./assets/objects/textured-cube.obj */ \"./src/assets/objects/textured-cube.obj\");\n/* harmony import */ var _assets_images_cube_texture_png__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./assets/images/cube-texture.png */ \"./src/assets/images/cube-texture.png\");\n\n\n\n\n\n\n\n\n\n\nconst canvas = document.querySelector('canvas');\nconst gl = canvas.getContext('webgl');\n\nconst width = document.body.offsetWidth;\nconst height = document.body.offsetHeight;\n\ncanvas.width = width * devicePixelRatio;\ncanvas.height = height * devicePixelRatio;\n\ncanvas.style.width = `${width}px`;\ncanvas.style.height = `${height}px`;\n\nconst vShader = gl.createShader(gl.VERTEX_SHADER);\nconst fShader = gl.createShader(gl.FRAGMENT_SHADER);\n\n(0,_gl_helpers__WEBPACK_IMPORTED_MODULE_2__.compileShader)(gl, vShader, _shaders_3d_textured_v_glsl__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n(0,_gl_helpers__WEBPACK_IMPORTED_MODULE_2__.compileShader)(gl, fShader, _shaders_3d_textured_f_glsl__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\nconst program = gl.createProgram();\n\ngl.attachShader(program, vShader);\ngl.attachShader(program, fShader);\n\ngl.linkProgram(program);\ngl.useProgram(program);\n\ngl.enable(gl.DEPTH_TEST);\n\nconst programInfo = (0,_gl_helpers__WEBPACK_IMPORTED_MODULE_2__.setupShaderInput)(gl, program, _shaders_3d_textured_v_glsl__WEBPACK_IMPORTED_MODULE_0__[\"default\"], _shaders_3d_textured_f_glsl__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\nfor (let i = 0; i < 4; i += 1) {\n  gl.enableVertexAttribArray(programInfo.attributeLocations.modelMatrix + i);\n}\n\nconst cube = new _Object3D__WEBPACK_IMPORTED_MODULE_3__.Object3D(_assets_objects_textured_cube_obj__WEBPACK_IMPORTED_MODULE_5__[\"default\"], [0, 0, 0], [1, 0, 0]);\n\nconst vertexBuffer = new _GLBuffer__WEBPACK_IMPORTED_MODULE_4__.GLBuffer(gl, gl.ARRAY_BUFFER, cube.vertices, gl.STATIC_DRAW);\nconst texCoordsBuffer = new _GLBuffer__WEBPACK_IMPORTED_MODULE_4__.GLBuffer(gl, gl.ARRAY_BUFFER, cube.texCoords, gl.STATIC_DRAW);\n\nvertexBuffer.bind(gl);\ngl.vertexAttribPointer(programInfo.attributeLocations.position, 3, gl.FLOAT, false, 0, 0);\n\ntexCoordsBuffer.bind(gl);\ngl.vertexAttribPointer(programInfo.attributeLocations.texCoord, 2, gl.FLOAT, false, 0, 0);\n\nconst viewMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__.create();\nconst projectionMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__.create();\n\ngl_matrix__WEBPACK_IMPORTED_MODULE_7__.perspective(\n  projectionMatrix,\n  Math.PI / 360 * 90,\n  canvas.width / canvas.height,\n  0.01,\n  100,\n);\n\ngl.uniformMatrix4fv(programInfo.uniformLocations.viewMatrix, false, viewMatrix);\ngl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);\n\ngl.viewport(0, 0, canvas.width, canvas.height);\n\nconst matrices = new Float32Array(100 * 100 * 4 * 4);\nconst modelMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__.create();\nconst rotationMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__.create();\n\nlet cubeIndex = 0;\n\nfor (let i = -50; i < 50; i += 1) {\n  for (let j = -50; j < 50; j += 1) {\n    const position = [i * 2, (Math.floor(Math.random() * 2) - 1) * 2, j * 2];\n    gl_matrix__WEBPACK_IMPORTED_MODULE_7__.fromTranslation(modelMatrix, position);\n\n    gl_matrix__WEBPACK_IMPORTED_MODULE_7__.fromRotation(rotationMatrix, Math.PI * Math.round(Math.random() * 4), [0, 1, 0]);\n    gl_matrix__WEBPACK_IMPORTED_MODULE_7__.multiply(modelMatrix, modelMatrix, rotationMatrix);\n\n    modelMatrix.forEach((value, index) => {\n      matrices[cubeIndex * 4 * 4 + index] = value;\n    });\n\n    cubeIndex += 1;\n  }\n}\n\nconst matricesBuffer = new _GLBuffer__WEBPACK_IMPORTED_MODULE_4__.GLBuffer(gl, gl.ARRAY_BUFFER, matrices, gl.STATIC_DRAW);\n\nconst offset = 4 * 4;\nconst stride = offset * 4;\n\nconst ext = gl.getExtension('ANGLE_instanced_arrays');\n\nfor (let i = 0; i < 4; i += 1) {\n  gl.vertexAttribPointer(programInfo.attributeLocations.modelMatrix + i, 4, gl.FLOAT, false, stride, i * offset);\n  ext.vertexAttribDivisorANGLE(programInfo.attributeLocations.modelMatrix + i, 1);\n}\n\nconst cameraPosition = [0, 10, 0];\nconst cameraFocusPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_8__.fromValues(30, 0, 0);\nconst cameraFocusPointMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_7__.create();\n\ngl_matrix__WEBPACK_IMPORTED_MODULE_7__.fromTranslation(cameraFocusPointMatrix, cameraFocusPoint);\n\nfunction frame() {\n  gl_matrix__WEBPACK_IMPORTED_MODULE_7__.translate(cameraFocusPointMatrix, cameraFocusPointMatrix, [-30, 0, 0]);\n  gl_matrix__WEBPACK_IMPORTED_MODULE_7__.rotateY(cameraFocusPointMatrix, cameraFocusPointMatrix, Math.PI / 360);\n  gl_matrix__WEBPACK_IMPORTED_MODULE_7__.translate(cameraFocusPointMatrix, cameraFocusPointMatrix, [30, 0, 0]);\n\n  gl_matrix__WEBPACK_IMPORTED_MODULE_7__.getTranslation(cameraFocusPoint, cameraFocusPointMatrix);\n\n  gl_matrix__WEBPACK_IMPORTED_MODULE_7__.lookAt(viewMatrix, cameraPosition, cameraFocusPoint, [0, 1, 0]);\n  gl.uniformMatrix4fv(programInfo.uniformLocations.viewMatrix, false, viewMatrix);\n\n  ext.drawArraysInstancedANGLE(gl.TRIANGLES, 0, vertexBuffer.data.length / 3, 100 * 100);\n\n  requestAnimationFrame(frame);\n}\n\n(0,_gl_helpers__WEBPACK_IMPORTED_MODULE_2__.loadImage)(_assets_images_cube_texture_png__WEBPACK_IMPORTED_MODULE_6__[\"default\"])\n  .then((image) => {\n    const texture = (0,_gl_helpers__WEBPACK_IMPORTED_MODULE_2__.createTexture)(gl);\n    (0,_gl_helpers__WEBPACK_IMPORTED_MODULE_2__.setImage)(gl, texture, image);\n\n    frame();\n  });\n\n\n//# sourceURL=webpack://webgl-month/./src/3d-textured.js?");

/***/ }),

/***/ "./src/GLBuffer.js":
/*!*************************!*\
  !*** ./src/GLBuffer.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GLBuffer\": () => (/* binding */ GLBuffer)\n/* harmony export */ });\nclass GLBuffer {\n  constructor(gl, target, data, usage) {\n    this.target = target;\n    this.data = data;\n    this.glBuffer = gl.createBuffer();\n\n    if (typeof data !== 'undefined') {\n      this.setData(gl, data, usage);\n    }\n  }\n\n  bind(gl) {\n    gl.bindBuffer(this.target, this.glBuffer);\n  }\n\n  setData(gl, data, usage) {\n    this.data = data;\n    this.bind(gl);\n    gl.bufferData(this.target, this.data, usage);\n  }\n}\n\n\n//# sourceURL=webpack://webgl-month/./src/GLBuffer.js?");

/***/ }),

/***/ "./src/Object3D.js":
/*!*************************!*\
  !*** ./src/Object3D.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Object3D\": () => (/* binding */ Object3D)\n/* harmony export */ });\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/esm/mat4.js\");\n/* harmony import */ var _gl_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gl-helpers */ \"./src/gl-helpers.js\");\n\n\n\n\nclass Object3D {\n  constructor(source, position, color) {\n    const { vertices, normals, texCoords } = (0,_gl_helpers__WEBPACK_IMPORTED_MODULE_0__.parseObj)(source);\n\n    this.vertices = vertices;\n    this.normals = normals;\n    this.texCoords = texCoords;\n    this.position = position;\n\n    this.modelMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();\n    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.fromTranslation(this.modelMatrix, position);\n    this._normalMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_1__.create();\n\n    this.color = color;\n  }\n\n  get normalMatrix() {\n    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.invert(this._normalMatrix, this.modelMatrix);\n    gl_matrix__WEBPACK_IMPORTED_MODULE_1__.transpose(this._normalMatrix, this._normalMatrix);\n\n    return this._normalMatrix;\n  }\n}\n\n\n//# sourceURL=webpack://webgl-month/./src/Object3D.js?");

/***/ }),

/***/ "./src/gl-helpers.js":
/*!***************************!*\
  !*** ./src/gl-helpers.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compileShader\": () => (/* binding */ compileShader),\n/* harmony export */   \"setupShaderInput\": () => (/* binding */ setupShaderInput),\n/* harmony export */   \"parseVec\": () => (/* binding */ parseVec),\n/* harmony export */   \"parseFace\": () => (/* binding */ parseFace),\n/* harmony export */   \"parseObj\": () => (/* binding */ parseObj),\n/* harmony export */   \"loadImage\": () => (/* binding */ loadImage),\n/* harmony export */   \"createTexture\": () => (/* binding */ createTexture),\n/* harmony export */   \"setImage\": () => (/* binding */ setImage)\n/* harmony export */ });\n/* harmony import */ var glsl_extract_sync__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! glsl-extract-sync */ \"./node_modules/glsl-extract-sync/index.js\");\n/* harmony import */ var glsl_extract_sync__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(glsl_extract_sync__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction compileShader(gl, shader, source) {\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  const log = gl.getShaderInfoLog(shader);\n\n  if (log) {\n    throw new Error(log);\n  }\n}\n\nfunction setupShaderInput(gl, program, vShaderSource, fShaderSource) {\n  const vShaderInfo = glsl_extract_sync__WEBPACK_IMPORTED_MODULE_0___default()(vShaderSource);\n  const fShaderInfo = glsl_extract_sync__WEBPACK_IMPORTED_MODULE_0___default()(fShaderSource);\n\n  const attributes = vShaderInfo.attributes;\n  const uniforms = [\n    ...vShaderInfo.uniforms,\n    ...fShaderInfo.uniforms,\n  ];\n\n  const attributeLocations = attributes.reduce((attrsMap, attr) => {\n    attrsMap[attr.name] = gl.getAttribLocation(program, attr.name);\n    return attrsMap;\n  }, {});\n\n  attributes.forEach((attr) => {\n    gl.enableVertexAttribArray(attributeLocations[attr.name]);\n  });\n\n  const uniformLocations = uniforms.reduce((uniformsMap, uniform) => {\n    uniformsMap[uniform.name] = gl.getUniformLocation(program, uniform.name);\n    return uniformsMap;\n  }, {});\n\n  return {\n    attributeLocations,\n    uniformLocations,\n  };\n}\n\nfunction parseVec(string, prefix) {\n  return string.replace(prefix, '').split(' ').map(Number);\n}\n\nfunction parseFace(string) {\n  return string.replace('f ', '').split(' ').map((chunk) => {\n    return chunk.split('/').map(Number);\n  });\n}\n\nfunction parseObj(objSource) {\n  const _vertices = [];\n  const _normals = [];\n  const _texCoords = [];\n\n  const vertexIndices = [];\n  const normalIndices = [];\n  const texCoordIndices = [];\n\n  objSource.split('\\n').forEach((line) => {\n    if (line.startsWith('v ')) {\n      _vertices.push(parseVec(line, 'v '));\n    }\n\n    if (line.startsWith('vt ')) {\n      _texCoords.push(parseVec(line, 'vt '));\n    }\n\n    if (line.startsWith('vn ')) {\n      _normals.push(parseVec(line, 'vn '))\n    }\n\n    if (line.startsWith('f ')) {\n      const parsedFace = parseFace(line);\n\n      vertexIndices.push(...parsedFace.map((face) => face[0] - 1));\n      texCoordIndices.push(...parsedFace.map((face) => face[1] - 1));\n      normalIndices.push(...parsedFace.map((face) => face[2] - 1));\n    }\n  });\n\n  const vertices = [];\n  const normals = [];\n  const texCoords = [];\n\n  for (let i = 0; i < vertexIndices.length; i += 1) {\n    const vertexIndex = vertexIndices[i];\n    const normalIndex = normalIndices[i];\n    const texCoordIndex = texCoordIndices[i];\n\n    const vertex = _vertices[vertexIndex];\n    const normal = _normals[normalIndex];\n    const texCoord = _texCoords[texCoordIndex];\n\n    vertices.push(...vertex);\n    normals.push(...normal);\n\n    if (texCoord) {\n      texCoords.push(...texCoord);\n    }\n  }\n\n  return {\n    vertices: new Float32Array(vertices),\n    normals: new Float32Array(normals),\n    texCoords: new Float32Array(texCoords),\n  };\n}\n\nasync function loadImage(src) {\n  const img = new Image();\n\n  let _resolve;\n  const p = new Promise((resolve) => _resolve = resolve);\n\n  img.onload = () => {\n    _resolve(img);\n  }\n\n  img.src = src;\n\n  return p;\n}\n\nfunction createTexture(gl) {\n  const texture = gl.createTexture();\n\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n  return texture;\n}\n\nfunction setImage(gl, texture, img) {\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    0,\n    gl.RGBA,\n    gl.RGBA,\n    gl.UNSIGNED_BYTE,\n    img,\n  );\n}\n\n\n//# sourceURL=webpack://webgl-month/./src/gl-helpers.js?");

/***/ }),

/***/ "?3e83":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://webgl-month/util_(ignored)?");

/***/ }),

/***/ "?19e6":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://webgl-month/util_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/3d-textured.js");
/******/ 	
/******/ })()
;